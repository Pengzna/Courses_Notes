# 数据结构与算法

## chapter1、Data and Algorithm

> ###  Data definition：

is the carrier of information

Data is a set of numbers, characters and other symbols.

#### 	Data type

​		-is a set of values together with a operation set that operate on these values.

​		-大部分编程语言提供两种预定义的数据类型

​			-Atom data type ---- int, float, double......

​			-Structure data type ---- array, struct......

> ### What is Data Structure

a data structure is a data object(D) together with the relationships(R) among the data members that compose the object.



> ### ADT and OO

#### ADTs:

​	Abstract Data Types

​	是将类型和与这个类型有关的操作集合封装在一起的数据模型。

​		-Abstract: is a method used to hide the information.

​		-思想：将数据类型的使用与它的表示（机内存储）、实现（机内操作的实现）分开。更确切的

​		说，把一个数据类型的**表示**及在这个类型上的操作**实现**封装到一个程序模块中，用户不必知道他

#### OO:

​	object-oriented = object + class + inherit + communicate

​		-object: attribute values + operates

> ### Algorithm definition

#### Algorithm :

​	an operation sequence of soluting a problem

#### Properties:

​	-Input specified

​	-Output specified (算法是有输入和输出的)

​	-Definiteness (确定性、定性的，每一个算法都必须定义的很明确、书上的概念)（考研题考过）/ Deterministic（确定性算法，是算法的分类，算法包括deterministic和nondeterministic）

-确定性算法：对于一个固定的输入，算法有一个固定的输出

​	-Effectiveness

​	-Finiteness (有穷性)

> ### 算法思想

#### 1.Inducive

basis:

inducive condition:

inducive proof:

Q.E.D.

#### 2. Recursive 

​	C语言不断调用函数就是不断压栈的过程，每调用一个新函数则新创建一个栈空间

​	调用构成回路即构成递归!

​		eg: $f_1 -> f_2 -> f_3 -> f_1$

​	-牺牲执行效率，提高开发效率

​	$eg_1$ 全排列算法:

![image-20210910173126898](数据结构与算法.assets/image-20210910173126898.png)

m是数组最后一个元素的下标, k是把数组分为两个部分的指标。

递归到m-1个元素的全排列和m个元素全排列的递推关系。

用循环找递推关系：每次把单独拿出来的元素跟后面全排列中的某一个元素交换顺序。

#### 2.运行时和编译

运行时（.exe)和编译是完全不同的两个概念

​	-应用举例: 运行时才能确定变量的大小, 所以编译时, 如果用变量作为数组的长度, 编译器无法确定数组的	大小, 从而报错!

​	In C++, the compiler must know the amount of memory to allocate for an array at compile time. However, the value of a variable is not known until run time. This is why you are not allowed to use a variable for the size of an array.



this在Java里对象的引用，在C++里是一个指针

> ### Generic Objects in Java

对于仅仅是参数数据类型不同的方法，可以使用“泛型”

## chapter2、complexity

### Space Complexity

​	-$S_{(n)}$

​	-指令空间

​	-数据空间

​	-栈空间

![image-20210917161528131](数据结构与算法.assets/image-20210917161528131.png)

主要看运行时的动态占用空间

### Time Complexity

​	-$T_{(p)}$

​	本质上是CPU的工作量

​	![image-20210917171945989](数据结构与算法.assets/image-20210917171945989.png)

​	编译时间一般不算算法的时间复杂度

​	算时间复杂度也是粗略的算一下，只算主要消耗时间的步骤



### Rank sort（秩排序）

​	先把数组里每个数的排名得到，然后再根据排名进行排序、调整

![image-20210924162059574](数据结构与算法.assets/image-20210924162059574.png)

生成排名算法：

![image-20210924162310868](数据结构与算法.assets/image-20210924162310868.png)

二重循环保证每两个数据都能比一次，两两比，一旦比过了rank++；



![image-20210924162828057](数据结构与算法.assets/image-20210924162828057.png)

这个循环的目的是保证r[i] == i

### Sequential Search（顺序查找）

![image-20210924163619853](数据结构与算法.assets/image-20210924163619853.png)

最坏情况：比较次数是n

平均情况：每种情况的概率加起来求算术平均

![image-20210924163907131](数据结构与算法.assets/image-20210924163907131.png)

### Insertion sort（插入排序）

![image-20210924164736112](数据结构与算法.assets/image-20210924164736112.png)

![image-20210924165006084](数据结构与算法.assets/image-20210924165006084.png)

边比边调整数组，随时为x（待插入元素）腾出位置，最终直接插入

完整实现：

双重循环，最外层循环每次加一个a[i]

![image-20210924165747450](数据结构与算法.assets/image-20210924165747450.png)



### 渐进时间复杂度

![image-20210928090857501](数据结构与算法.assets/image-20210928090857501.png)



![image-20210928090913794](数据结构与算法.assets/image-20210928090913794.png)

![image-20210928090919099](数据结构与算法.assets/image-20210928090919099.png)

$O(0)<O(log_2n) < O(n) < O(2^n) < O(n!) < O(n^n)$

批注：计算机中对数默认为2

​				$O(0)$表示常数复杂度

做算法复杂度分析的时候**关注量级**



### Binary Search（折半查找）

可以把顺序查找的线性复杂度降为对数复杂度

把每次的数据和中间的数据比（前提是数据库是已经分好类的）



### 找最大子序列和

使用三重循环找到所有子序列，然后用一个标志位maxSum来记录最大子序列的和

优化1：只使用两重循环，第一层循环i定起点，第二层循环j定终点，然后每次加一个新元素只是在原有和的基础上加一个元素



### 算法思想：分治法

分：把问题分成两个大致相等的问题，使用递归等方法找到他们的解

治：把二者合并在一起，并通过一些附加工作得到答案

以找最大子序列的问题为例：把数列分为两半，先找两边的最大子序列，然后再从中间出发，找左右两边起点/终点固定的最大子序列，二者拼起来和左右两边的最大子序列比较

**注1：分治法通常是跟递归一起使用的，以此题为例，即：每次求左右两边结果的时候同样要使			 用分治法**

**注2：递归更多的是使用递推公式，而分治法则是平均二分**



看起来，好像算递归/分治算法的复杂度是看每次栈的复杂度 * 栈数

由此分析出分治法找最大子序列和的时间复杂度是$O(n * log_2n)$ [经计算，每次调用栈的复杂度正好都是n]



### Euclid's Algorithm（辗转相除法）

![image-20211008161544040](数据结构与算法.assets/image-20211008161544040.png)

**算法思想：**

m -> n -> m % n -> n % (m % n) -> ...不停往后走一格

- eg： 30 7 -> 2 -> 1 -> 结束，最大公因数是1
- 首先明确：此算法的最坏情况是m和n互素，这样m和n相除的轮数尽可能多
- 然后从tail开始分析，为保证辗转相除的次数尽可能大，要保证在同等规模除的情况下，数据尽可能的小，因此：
  -  ... 13 -> 8 -> 5 -> 3 -> 2 -> 1（tail）
  - 正好是斐波那契数列
  - 比如要得到1000以内辗转相除法的最大迭代次数，即取1000以内最大的相邻两项斐波那契额数列，此时迭代次数即为斐波那契数列的项数 - 3
  - 斐波那契数列是对数量级的（可以用数列的递推公式来推导）
    - 因此此算法$O(f(n)) = O(logN)$



### $O(n)\ and\ Ω(n)$

- 课本P33 
- $o(n)$跟$O(n)$都表示最坏情况复杂度，但是$o(n)$表示算法无法达到该理论最坏复杂度



## chapter3、LinearList

### Set & Collection的区别

- Set强调元素只出现一次，而Collection无此要求
- Java里，Collection是List`, `Queue`, `Deque的父类，以它为接口可以提供更多多态选择
- Collection includes Set, as well as List.



### The List ADT

- 课本P43

- 线性表存在第一个元素和最后一个元素

- 每个元素由一维下标组成
- 除了首尾，每个元素有后继和前序

![image-20211008171528454](数据结构与算法.assets/image-20211008171528454.png)



### Simple array implementation of Lists

- use an array to represent the instance of an object
- ![image-20211008171921131](数据结构与算法.assets/image-20211008171921131.png)



- PS：***ACN*** ： average comparison number
- 讲逻辑层的时候，下标起点为1；而讲物理层时，下标起点为0
- $remove(): O(n)$
- $insert(): O(n)$
- PS：***AMN*** ： average movement number
- **Merit:** easy search
- **Shortcoming:** insertion and deletion spend a lot of time



### Linked Lists

- 逻辑层和数组List一模一样，但是物理实现是通过单向链表实现的
- 删除首结点，Java和cpp操作不一样
- Java![image-20211008175219086](数据结构与算法.assets/image-20211008175219086.png)
- 而cpp要把first = first.next; delete[] first;
- 删除中间节点，需要before指针指向删除结点的前一个结点。Java仍然只需要一句代码
- ![image-20211008175543830](数据结构与算法.assets/image-20211008175543830.png)

#### 带表头结点的链表Header（dummy node）

- ![image-20211012081342835](数据结构与算法.assets/image-20211012081342835.png)
- 从第二个结点才开始存放数据
- header结点的数据区不放东西



- 默认的单链表是不带表头的单链表

#### Java中关于单链表的实现

- Class definition
  - ListNode —— 代表结点的类
  - LinkedList —— 代表表本身的类
  - LinkedListItr —— 代表位置的类（游标类，指向当前位置的引用/指针）
  - 以上都是包DataStructures的一部分

![image-20211012082207711](数据结构与算法.assets/image-20211012082207711.png)

![image-20211012082225912](数据结构与算法.assets/image-20211012082225912.png)

- 此处认链表是带头节点的单链表

![image-20211012082241226](数据结构与算法.assets/image-20211012082241226.png)



#### 相关操作复杂度

- 数据查找 find - O（n）
- 删除结点 delete - O（1）
- 插入结点 insert - O（1）



#### 线性链表的其他变形

- 双向链表（doubly linked list）

- 循环链表



#### Josephus问题

- 使用循环单链表，依次计数，然后每次删去第m个结点并打印该结点编号，当只剩下一个结点的时候结束算法

```c++
void Josephus(CircList<T>& Js, int num, int count){
    //the first param points to the first node of Js
    CircList<T> *p = Js.Locate(1), *pre = NULL;
    for(int i = 0; i < num - 1; i++){
        //count n-1 times, eventually remain one person.
        for(int j = 1; j < count; j++){
            //find the to be killed person.
            pre = p;
            p = p -> next;
        }
        //print message.
        cout << "The person to be killed is " << p -> data << endl;
        //delete the node.
        pre -> next = p -> next;
        //update the head pointer.
        if(first == p) first = p -> next;
        delete p;
        //important step! ensure next loop of program can run!
        p = pre -> next;
    }
    cout << "Eventually "<< first -> data << " survived!" << endl;
}
```

- 术语批注: rhs = right head side; lhs = left head side
  - 指的是operator左右两边的元素

#### 多项式计算

##### 数组实现

###### 思路

- 使用稠密表示
- 定义一个系数数组，数组下标和指数对应
  - 比如最高指数是1000，那么数组的下标至少要留到1000



###### 类定义

![image-20211015164551682](数据结构与算法.assets/image-20211015164551682.png)

###### 操作

![image-20211015164608317](数据结构与算法.assets/image-20211015164608317.png)

![image-20211015164619373](数据结构与算法.assets/image-20211015164619373.png)



##### 单链表实现

- 使用稀疏表示
- 课本P76

###### 类定义

```c++
struct Term{
    float coef; // 系数
    int exp; // 指数
    Term *next;
    //有参构造函数
    Term * InsertAfter(float c, int e);
    friend ostream& operator << (ostream&, const Term&);
}

class Polynomial{
   private:
    Term* first;
    friend ostream& operator << (ostream&, const Poynomial&);
    //友元函数，重载 >>
    //友元函数，重载+
    //友元函数, 重载*
    
   public:
    Polynomial() {first = new Term(0, -1);}
    Polynomial(Polynomial& R); //复制构造函数, 利用已有多项式对象R初始化当前多项式对象
    int maxOrder();//计算最大阶数
    Term* getFirst(){ return this.first; };
    
}
```

###### 操作

- 对于两个待加链表, 分别添加两个检测指针pa, pb, 依次扫描并比较exp域, 合适时完成coef域运算



#### 例题

![image-20211015174829056](数据结构与算法.assets/image-20211015174829056.png)

用两个指针记录？将一个指针移动到与另一个指针相距为k的地方，然后两个指针同时向后移，后一个指针指到null的时候前一个指针就是倒数第k个节点？（如果链表长度小于k的话进行特殊的判断）



### Radix Sort（计数排序）

按照进制的个数创建n个桶

然后依次按照数据的第1位进桶出桶、第2位进桶出桶...第n位进桶出桶

直到所有位数都进桶出桶，即排好数据



## chapter4、Stack & Queue

### Stack

- 定义
  - 只能在同一端插入和删除数据的数据结构
  - 插入和删除数据的一端叫栈顶，另一端叫栈底
  - LIFO（last-in-first-out）
- 基本操作
  - pop
  - push
  - peek
- 栈顶
  - 通过它来判断栈是否满、空，得到栈里元素的个数
  - 为0，表示还有一个元素
  - 为-1， 表示没有元素了


#### 实现

- 链表（一般定义栈顶为topOfStack，如果top == null，栈空）

- 数组（一般定义栈顶为数组最末尾元素的下标，数组事先定义一个MaxLen，如果top == -1，栈空）

### 应用：表达式括号匹配

![image-20211026094249388](数据结构与算法.assets/image-20211026094249388.png)

![image-20211026094258316](数据结构与算法.assets/image-20211026094258316.png)

### Queue

- 一端进，一端出，不得插队

#### 实现

- 数组
  - To add an element:  back=back+1; theArray[back]=x; 
  - To delete an element: two methods: 
    - front=front+1; O(1) 
    - shift the queue one position left; O(n)

  - 技巧：把数组视作环

![image-20211026082702626](数据结构与算法.assets/image-20211026082702626.png)

![image-20211026082736122](数据结构与算法.assets/image-20211026082736122.png)

- 单链表

#### 应用：打印杨辉三角

- s是队首的缓存

- i的for循环表示打印第i行

- k的for循环表示打印数据前的空格，这里认为10是杨辉三角长度的一半

- 然后再进一个0，表示末尾的0，用来和最后的1相加生成下一行的末1

- 第三个for循环表示第i行要处理i + 2个数据

- 然后每次出队数据，并新进一个数据

- 最后的if是保证不打印队列最后的0
  - 而最后的0正好出队，作为变量t赋给s，成为下一行的s（队首缓存）

![image-20211026090543330](数据结构与算法.assets/image-20211026090543330.png)

## chapter5、Tree

### 定义

- a tree T is a collection of nodes(element)
- The collection can be empty
- otherwise a tree consists of  a distinguished node **r** called the **root**, and zero or more nonempty **sub trees $T_1, T_2, ..., T_k$**

一般把根结点画在上

### 二叉树

每个结点只有两个or一个子树，分为左子树和右子树

- 性质
  - 如果n个结点，边必定是n - 1
  - 第i个结点的个数$\le 2^i$
  - 树叶（度数为0的结点）个数为$n_0$，度数为2的结点个数为$n_2 + 1$
  - 结点数为n的二叉树最大高度和最小高度的推导（只有一条主分支 and 全是二分支）
- 满二叉树：所有层的位置全部占满的树
- 完全二叉树：满二叉树按照顺序删掉若干结点后的树
  - 意义：完全二叉树强调结点的位置，每一个结点在树里的位置是固定的
    - 因此可以用编号来表示结点，
  - PS: 编号默认从0开始编, 最后一个结点的编号是n - 1
  - 性质:

![image-20211029163346573](数据结构与算法.assets/image-20211029163346573.png)

![image-20211029163522811](数据结构与算法.assets/image-20211029163522811.png)

PS：（2）中的表达式是向上取整

### 二叉树的物理实现

#### Formula-Based Representation

##### Array representation

模拟完全二叉树进行实现 --> 把完全二叉树的编号看作数组下标

如果实现的是非完全二叉树，则可以把其看成若干位为空的完全二叉树

- 适用于模拟完全二叉树/类完全二叉树（缺的结点比较少的）

eg：

![image-20211029164008622](数据结构与算法.assets/image-20211029164008622.png)

##### Linked representation

![image-20211029165032667](数据结构与算法.assets/image-20211029165032667.png)

- data字段跟树的功能有关
- 左右是指针（引用），指向左右子节点
- 甚至可以用静态链表来表示

![image-20211029165659904](数据结构与算法.assets/image-20211029165659904.png)

- 创建结点时是从下往上构建的（从上面添加结点）
- 删除结点时从上往下删，是makeTree的逆操作

#### 二叉树的遍历

- 策略：递归 每一次遍历分为V（结点）、L（访问左子树）、R（访问右子树）
- 根据遍历左子树的顺序，分为前序遍历、中序遍历、后序遍历
- 而另外一种遍历策略是level order（层次遍历），即按照每一层从左往右遍历

##### Preorder

![image-20211105163519898](数据结构与算法.assets/image-20211105163519898.png)

##### Inorder

![image-20211105163535980](数据结构与算法.assets/image-20211105163535980.png)

##### Postorder

![image-20211105163548280](数据结构与算法.assets/image-20211105163548280.png)

------

- 思考技巧：从最底层左边leaf开始看，逐层套遍历规则。（模仿递归，递归本质也是从最后一层开始出栈）

![image-20211105162936318](数据结构与算法.assets/image-20211105162936318.png)

#### 用栈实现树的遍历

总体来说有2层循环，while和栈结构控制递归。当指针p指向新一个结点且轮到while时，代表进入下一个递归。

算法很精妙！慢慢体会

##### Inorder

![image-20211105165842206](数据结构与算法.assets/image-20211105165842206.png)

##### Postorder

对于后续遍历来说，需要对每一个结点加一个tag，记录是从左子树回来的还是右子树回来的

如果当前指针为空，代表该分支子树已经遍历完。此时返回到父结点，无论如何都先将其pop出来

- 如果父结点tag为0，则将其tag修改为1后重新push入栈，然后开始遍历其右子树
- 如果父结点tag为1，则将其打印并继续pop栈，将p指向上一层结点

![image-20211105171519047](数据结构与算法.assets/image-20211105171519047.png)

### 建立一棵二叉树的方法

输入一个String，系统基于String调用相应算法进行创建

#### 利用先序、中序构造

ABDCEGFHI

DBAEGCHFI

#### 利用二叉树的广义表构造

A(B(D), C(E( , G), F(H,I)))

![image-20211109081709351](数据结构与算法.assets/image-20211109081709351.png)

- 先通过先序遍历找到整个树的根节点
- 再通过顺序查找找到中序遍历的根节点下标
- 则对于prestemp，其（1，inpos）的substr即为左子树
- 对于instemp，其（0，inpos - 1）的substr即为左子树
- 然后递归调用createBT，其中根节点指向原根节点的左子树
- 右子树处理方法相同

### 树的存储方式

- 广义表表示
- 双亲表示法
- 左子女-右兄弟表示法（常考！）

![image-20211109083629483](数据结构与算法.assets/image-20211109083629483.png)

- 如果根节点a有右子树的话，说明原树是一个森林

#### 利用二叉树表示广义树

![image-20211109084332118](数据结构与算法.assets/image-20211109084332118.png)

- 给原树根节点插入子结点方法

![image-20211109084443216](数据结构与算法.assets/image-20211109084443216.png)

### 树的遍历

#### 深度优先

#### 广度优先

![image-20211109091112505](数据结构与算法.assets/image-20211109091112505.png)

- 注意：物理层二叉树的**中序**遍历和逻辑层树的**后序**遍历相同

### Thread Tree

- 为了充分利用n结点二叉树的2n个链域（指针）
- 好处是可以使前驱、后继等运算更快
- 在二叉树的n+1个空指针中放入一些线索化指针

一个栗子

![image-20211109092236251](数据结构与算法.assets/image-20211109092236251.png)

有了线索树之后，遍历等操作不需要递归和栈了

代码：

- first（）函数负责找到树中序遍历的第一个结点：即一直往左走到头
- next（）函数先把p指向current->rightchild
  - 如果rightchild是后继，即为所求
  - 如果rightchild是右子树的根节点，则找到右子树最左边的结点（即找到右子树的first（））

![image-20211109093816002](数据结构与算法.assets/image-20211109093816002.png)

#### 中序遍历算法

![image-20211109094201760](数据结构与算法.assets/image-20211109094201760.png)

好处：降低算法复杂度

#### 构造中序线索树

对已存在的一棵二叉树建立中序线索树 

- 分析： 与中序遍历算法差不多， 但是要填左空域 右空域的前驱、后继指针。 所以除了流动指针p外， 还要加一个pre指针，它总是指向遍历指针p的中序 下的前驱结点。

![image-20211109094423119](数据结构与算法.assets/image-20211109094423119.png)

算法流程类似于用栈实现中序遍历二叉树

但是之前的算法中，当遍历到指针域为空时，要cout操作

此算法把cout操作改为初始化指针域即可

![image-20211109094857480](数据结构与算法.assets/image-20211109094857480.png)

### Huffman Tree

