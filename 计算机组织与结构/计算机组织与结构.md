# 计算机组织与结构

## chapter1、intro

### 什么是计算机？

**通用电子数字计算机**

- 通用：不是一种专用设备，所有计算机在给予足够时间和容量存储器的条件下，都可以完成同样的计算。党希望完成新的计算时，不需要对计算机重新设计

### 计算机系统

- 硬件：处理器、存储器、外部设备

- 软件：程序、文档

### 组织与结构

组织：对编程人员不可见

结构：对编程人员可见

### 计算机简史

#### 第一代：真空管

ENIAC：第一台通用计算机

EDVAC：采用冯.诺伊曼结构（普林斯顿结构）

​	冯诺依曼结构的三个基本原则：

- 二进制

- 存储程序执行

- 五个组成部分

  -  主存储器：地址和存储的内容（important） 

  - 算数逻辑/处理单元：执行信息的实际处理

  - 程序控制单元：指挥信息的处理

  - 输入设备

  - 输出设备

#### 第二代：晶体管

体积更小、更便宜、发热更少，而且能以与电子管相同的方式建造计算机

使用更复杂的算数逻辑单元和控制器，使用高级编程语言

#### 第三代及后续：集成电路

#### 摩尔定律

- 每18个月晶体管的数量增加1倍

### 计算机发展：变与不变

![image-20210902151144693](计算机组织与结构.assets/image-20210902151144693.png)

### 计算机性能

> #### CPU性能

- 系统时钟

  -  时钟频率/时钟速度（单位：Hz）：计算机执行最基本操作的基本速率（以每秒周期数为单位）

  - 时钟周期/时钟滴答声：CPU的单个电子脉冲

  - 周期时间（单位：s）：两个脉冲之间的时间
    - 有时被称为**时钟周期**

![image-20210902153708538](计算机组织与结构.assets/image-20210902153708538.png)

> **但是有时，cpu会专门做一块硬件来处理某条特定的指令，使得这个特定的指令执行的特别快，显得cpu性能很好。为了防止这种以偏概全的作弊方法，并找到一种公平的方法来量化cpu性能我们引入**：

**![image-20210902154500534](计算机组织与结构.assets/image-20210902154500534.png)**

所以，有些常见的跑分软件的原理即：拿一堆基准程序来跑

![image-20210902154801831](计算机组织与结构.assets/image-20210902154801831.png)

$$MIPS = \frac{f}{CPI * 10^6}$$

## chapter2、计算机的顶层视图

### 计算机组件

- 数据和指令存储在单个读写存储器

- 该存储器的内容可按位置寻址，而无需考虑其中包含的数据类型

- 从一条指令到下一条指令以顺序方式执行（除非明确修改）

### CPU

- PC：程序计数器

- IR：指令寄存器

- MAR：存储器地址寄存器

- MBR：存储器缓冲寄存器

- I/O AR：I/O地址寄存器

- I/O BR：I/O缓冲寄存器

- 执行单元

- 问题：CPU在等待I/O设备时保持空闲

- 解决方法：

	- 中断：其他模块（例如I/O)可以中断正常处理顺序的机制

![image-20210909144019956](计算机组织与结构.assets/image-20210909144019956.png)

- 在等I/O 的时候中断以下去处理其他的程序，待I/O准备好以后，其打断CPU，让其继续未完成的			操作。

- 中断程序全部处理完了之后，再回到用户程序，即：中断程序优先级更高

​			![image-20210909144252335](计算机组织与结构.assets/image-20210909144252335.png)

### 存储器

​	问题：

- 主存和CPU之间传输数据的速度跟不上CPU的速度

​		![image-20210909151913203](计算机组织与结构.assets/image-20210909151913203.png)

​	解决：

- 添加一级或多级缓存（cache）以减少存储器访问频率并提高数据传输速率（层次式存储结构）

- 增大总线的数据宽度，来增加每次所能取出的位数

- ...

​	约束：

- 容量：越大越好

- 速度：跟上存储器

- 成本：相对于其他组件合理	

- 约束之间的关系：更短的访问时间，更高的每比特成本



### I/O模块

- 与CPU和内存交换从外部来源收集的数据

​	问题：I/O性能跟不上CPU速度的提升

​	解决：

- 缓冲

- 新的接口技术

- ...

### 系统总线

- 是连接两个或多个设备的通信通路

![image-20210909155044050](计算机组织与结构.assets/image-20210909155044050.png)

![image-20210914162101263](计算机组织与结构.assets/image-20210914162101263.png)

## chapter3、数据的机器级表示

### 编码：

​	定义：用少量简单的基本符号对复杂多样的信息进行一定规律的组合。

​	注意：不可能用离散有限的数据准确的表示连续无限的现实变量。

![image-20210914164710690](计算机组织与结构.assets/image-20210914164710690.png)

#### 	采用二进制的原因：

- 多种物理器件可以表示两种稳定的状态，用于表示0和1

- 二进制的编码和运算规则简单

- 1和0可以对应逻辑命题中的“真”与“假”

### 数值型数据的二进制数表示：

#### 		整数类型

##### 					无符号整数

##### 					有符号整数

原码，反码，移码，补码

- 定点整数：小数点固定在最后一位之后
- 定点小数：纯小数，约定小数点位置在符号位之后、有效数值部分最高位之前

  - 补码的表示：略

  - 补码的解析：$[X]_C = X_nX_{n-1}...X_1 \to X = -X_n * 2^{n-1} + X_{n-1} * 2^{n-2}+...+ X_1 * 2^0$

#### 二进制编码的十进制数表示

> ***即NBCD码***

##### 好处和特点：

- 可以同时保证精度和表示范围
- 但是牺牲了位数（存储空间）

​				![image-20210914180046150](计算机组织与结构.assets/image-20210914180046150.png)

#### 	浮点数的二进制数表示

![image-20210916151523973](计算机组织与结构.assets/image-20210916151523973.png)



- 基即为2，约定俗称为2.

- 规格化数的表示范围：

- 规格化数阶码的表示范围是$2^{-126} \sim 2^{127}$
- 阶码全0表示下溢区的数，而阶码全1表示上溢区 & $NaN$

![image-20210916153154301](计算机组织与结构.assets/image-20210916153154301.png)



此时计数：小数精度更高是因为，小数的相对偏差更大，精度要求更高。而大数精度要求较小，所以大数的精度可以稍微低一点

IEEE 754规定的舍入标准是**向偶数舍入**？

![image-20210922215703677](计算机组织与结构.assets/image-20210922215703677.png)

### float、double

- float只有23 + 1 = 24位有效位数，$10^7 \lt 2^{24} - 1 \lt 10^8$，所以理论上float的十进制有效位数是7位
  - 且它所能表示的数是离散分布在数轴上的
  - 每个区间$2^i \sim 2^{i+1}$中可以表示$2^{23}$个数
- double有52 + 1 = 53位有效位数，$10^{16} \lt 2^{53} - 1 \lt 10^{17}$所以理论上double的十进制有效位数是16位

## chapter4、数据校验码

### 差错

​	-分类

![image-20210924091940968](计算机组织与结构.assets/image-20210924091940968.png)

### 纠错

#### 	基本思想：

​		存储额外的信息以进行检错和校正

#### 	处理过程：

- 数据输入：
  - 使用函数$f$在M位数据$D$上生成K位校验码$C$

- 数据输出：

  - 使用函数$f$在M位数据$D^{'}$上生成K位校验码$C^{''}$，并与取出的K位码$C^{'}$（因为此时$C$在拿出来的时候也可能出错，产生$C^{’}$）进行比较

  - 没有检测到差错：使用数据$D^{'}$

  - 检测到差错且可以校正：校正数据$D^{'}$来生成数据$D^{''}$并用数据$D^{''}$

  - 检测到差错但无法纠正：报告

![image-20210924093118459](计算机组织与结构.assets/image-20210924093118459.png)

​		注意：数据在经过存储器/网络时会发生错误，经过存储器/网络后的数据会发生改变！

### 奇偶校验码

#### 	基本思想：

​		增加1位校验码来表示数据中的1的数量是奇数还是偶数

#### 	处理过程

​		假设处理数据$D=D_M...D_2D_1$

- 使用抑或操作

  - 特点：0跟任何数异或后还是那个数，因此0对异或运算没有影响。1和1异或生成1

  - 因此奇数个1异或后生成1，偶数个1异或后生成0

- 奇校验：奇数个1生成0，偶数个1生成1（和原数据放在一起，1的个数是奇数个）

- 偶校验：奇数个1生成1，偶数个1生成0（和原数据放在一起，1的个数是偶数个）			 ![image-20210924093745197](计算机组织与结构.assets/image-20210924093745197.png)

#### 		校验分析

### ![image-20210924094455298](计算机组织与结构.assets/image-20210924094455298.png)			

总的来说，如果01位数出错了，但总体的奇偶性没变，则无法检测出来

也无法检测出来具体是哪一位出现了错误

而且发现了错误后无法纠正。

我们默认：较短长度（如1字节）的数据每次出错只会1位出错，因此奇偶校验码适用于较短长度（如1字节）的数据进行检错。

### 海明码

#### 		基本思想

- 将数据分为几组，对每一组都使用奇偶校验码进行检错（可以是有重复的分组）

#### 		处理过程

- 将M位数据分成K组

- 数据输入

	- 为数据$D$中每组生成1位校验码，合并得到K位校验码$C$

- 数据输出

	- 为数据$D^{'}$中每组生成1位校验码，合并得到新的K位校验码$C^{''}$

- 检错：

	- 将**校验码$C^{''}$和取出的校验码$C^{'}（读出来的12位里的4位校验码）$**按位进行**异或**，生成K位故障字（syndrome word）

​	![image-20210924103342918](计算机组织与结构.assets/image-20210924103342918.png)

数据位出错和校验码出错分别有M和K种情形

且我们假设数据出错和校验码出错不会同时发生。

通过设定M，我们可以求出需要K的最小值



#### 故障字的作用：

​	每种取值都反映一种情形（数据出错/校验码出错/未出错）

​	规则：

​		全都是0：没有检测到错误

​		有且仅有1位是1：错误发生在校验码的某一位，不需要校正（我们假设数据和校验码一起最多只有1位出错）

​		有多位为1：错误发生在数据中的某一位，将$D^{'}$对应数据位取反即可纠正。（得到	$D^{''}$（某一个数据参与且仅参与了多个组）



#### 校验分析

![image-20210924104954814](计算机组织与结构.assets/image-20210924104954814.png)



若故障字哪几位数值为1，则对应校验码出错（校验码$C_n$在$2^n$位上），说明其内有某个数据位出错。找出公共的数据位，即为出错的位



我们先规定数据位/校验码与故障字的关系，然后由此可以推导出数据位的划分（如何分组）

- 比如：$D_8$出错对应的故障字是1100，第四位和第三位有1，所以$C_3$和$C_4$的异或里$D_8$参与了运算

#### 本章作业会考！！！

### 循环冗余校验

​	适用于以流格式存储和传输大量数据

​	用数学函数生成数据和校验码之间的关系

#### 	基本思想

​		假设数据有M位，**左移数据K位（右侧补0）**，并用K+1位生成多项式除它（模2运算）

​		采用K位余数作为校验码

​		**把校验码放在数据（不含补的0）后面**，一同存储或传输

#### 	校错

​		如果M+K位内容可以被生成多项式除尽，则没有检测到错误

​		否则，发生错误

![image-20210924111337400](计算机组织与结构.assets/image-20210924111337400.png)

### 补充：模2除法

模除的意思是做除法取余数（除完不要结果只要余数）
模x除，说的是除以几取余数。例如模10除就是除10取余，例如100做模十，余数就是0。不过人类一般是用十进制的，计算机用二进制的，所以这里的模x又有用x进制的意思了，例如100模二，结果仍然是0（这里是二进制数字100也就是十进制的4）
计算机模二除用的是异或运算，因为按位异或的结果与除法结果相同。



模2除法的特点就是：每一位除的结果不影响其它位，即不向上一位借位

模2除法原则：1、**被除数的首位为1，商为1**

​								2、**被除数的首位为0，商为0**
​    
​								3、**模2除法在减的时候等同于按位异或**，要保证每次除完首位都为0，才能进行右移
​    
​								4、计算时每次右移一位，当被除数的位数小于除数，其为余数

​								5、如果右移后，被除数首位为零，就除以全零



## chapter5、整数运算

### 算术逻辑单元（ALU）

### 全加器（最基本的单元）

#### 	串行进位加法器

- 作用：完成一位（1 bit）的加法

![image-20210928164355219](计算机组织与结构.assets/image-20210928164355219.png)

$C_i$表示的是三个与运算做完后完成或运算（注意，这里的三个与运算可以同时进行）

但是$S_i$的抑或的有先后顺序的，x和y先异或好准备就绪，等着$C_{i-1}$

求$C$的延迟：$1ty + 1ty = 2ty$

求$S_i$的延迟：$3ty + 3ty = 6ty$

而计算异或时是要考虑同步的



#### 一个计算延迟的栗子

![image-20210928170116651](计算机组织与结构.assets/image-20210928170116651.png)

but 在$S_1$和$S_2$时，仍然是$6ty$，不满足$2n+1$。

#### 	

#### 	全先行进位加法器

- 区别：进位不是全加器一个个算了，而是定义辅助函数计算

![image-20210928172701168](计算机组织与结构.assets/image-20210928172701168.png)

**注：$P_i$为进位传递，$G_i$为进位生成**

**注：$C$是先做与再做或**



![image-20210928173419246](计算机组织与结构.assets/image-20210928173419246.png)

步骤1：先求所有的P和G —— 1ty

步骤2：求C —— 2ty **（和步骤1 同步）**

步骤3：X和Y异或—— 3ty **（步骤1、2和步骤3异步）**

步骤4：把步骤3的结果和C做异或，求得S —— 3ty **（和步骤1、2、3是异步的）**



##### 改进：

![image-20210928175215216](计算机组织与结构.assets/image-20210928175215216.png)

最后还要得到一个$C_{32}$，所以最后再还有一个（2+3）= 5ty



### 两种判断溢出的方法

![image-20210930140815966](计算机组织与结构.assets/image-20210930140815966.png)

注：溢出只可能发生在$X_n$和$Y_n$同号的情况下



### 减法电路

![image-20210930141449096](计算机组织与结构.assets/image-20210930141449096.png)

注：Mux指的是多路选择器（multiplexer）

​		 此电路把加法和减法做了一个统一，通过Sub信号决定多路选择器选择Y还是Y的	  取反

- 对于无符号数运算，可以通过CF的值判断是否发生了借位（够不够减）
- 对于有符号运算，则不能通过CF的值判断是否发生了借位（比如-68 - 80 = -148）
  - 一般通过SF和OF
  - 或者通过ZF判断



### 乘法

![image-20210930141658769](计算机组织与结构.assets/image-20210930141658769.png)

手工演算二进制乘法其实很类似手工演算十进制乘法

如果$Y_i = 0$，只执行移位操作

#### 一个栗子

![image-20210930142310031](计算机组织与结构.assets/image-20210930142310031.png)

![image-20210930142654732](计算机组织与结构.assets/image-20210930142654732.png)

注：把部分积P和乘数Y存在一个寄存器里面，因为Y和P的位数此消彼长，始终满足长度之和位2n的关系，所以如此操作可以充分利用存储空间

**注意：要考虑进位！！！**

***例子***

![image-20210930142807557](计算机组织与结构.assets/image-20210930142807557.png)

**问题**：乘法在补码中可能会失效👇

![image-20210930142858546](计算机组织与结构.assets/image-20210930142858546.png)

##### 布斯乘法

***解决方法***：**布斯乘法**

![image-20210930143122228](计算机组织与结构.assets/image-20210930143122228.png)

把补码表示的Y用真值表示公式展开

精妙之处在第三行，利用变形使得式子形式统一（$Y_0 = 0$）

![image-20210930143457365](计算机组织与结构.assets/image-20210930143457365.png)

注1：第二点的意思是：$Y_i-Y_{i+1}$有$0,-1,1$三种取值可能，所以可能会对部分积产生三种影响

注2：应该使用带符号整数的算术右移，即sign_ext(始终保证右移是除以2的操作)



### 除法

#### 	恢复余数除法：

![image-20210930144932843](计算机组织与结构.assets/image-20210930144932843.png)

![image-20210930145148810](计算机组织与结构.assets/image-20210930145148810.png)

![image-20210930145328979](计算机组织与结构.assets/image-20210930145328979.png)

![image-20210930145655925](计算机组织与结构.assets/image-20210930145655925.png)

先把除数右移，让其最高位和被除数的次高位对齐

然后不断的把除数右移，商左移（商左移时通过控制逻辑判断是补0还是补1）



##### 优化

​	观察到余数（被除数）和商也满足此消彼长的关系，故将它们放在一起存储

![image-20210930150256487](计算机组织与结构.assets/image-20210930150256487.png)

![image-20210930150359357](计算机组织与结构.assets/image-20210930150359357.png)



PS：-7 / -2 = -3 ... -1

***余数减去除数之后，符号不能改变！***

***总之是要让余数的绝对值不断变小且让其符号不改变***

![image-20210930150744612](计算机组织与结构.assets/image-20210930150744612.png)

![image-20210930151318172](计算机组织与结构.assets/image-20210930151318172.png)

- 标红的一点即为:把商取反+1.



##### 一个栗子

![image-20210930151438154](计算机组织与结构.assets/image-20210930151438154.png)



我们判断是否"够减"时不是直观肉眼观察的, 而是先计算(同号相减、异号相加)，然后看结果相对于余数符号是否改变。若改变了则恢复，商0；反之保留运算结果，商1。

##### 思考：

有时候余数的符号会不等于初始被除数的符号，此时判断够减是以原始被除数的符号为准还是以余数的符号为准？

- 看书上的栗子好像是以初始被除数的符号为准



#### 不恢复余数除法

​	基本原理

![image-20210930153304893](计算机组织与结构.assets/image-20210930153304893.png)

![image-20210930153401422](计算机组织与结构.assets/image-20210930153401422.png)

即如果余数和除数符号相同，左移减。否则左移加

![image-20210930153523021](计算机组织与结构.assets/image-20210930153523021.png)

##### 一个栗子

![image-20210930153550444](计算机组织与结构.assets/image-20210930153550444.png)

不恢复余数除法是直接对齐的，且第一次运算得到的是溢出位，不是真正的商，到最后要左移一位把其去掉

##### 思考：

有时候不恢复余数除法会失效，什么时候？如何解决？

- 如果中间余数结果出现全0时，到底是判为够减还是不够减

- 正好整除的时候失效，因为不恢复余数除法使用于有余数除法，其结束运算标准是除的次数，而不是余数是否为0



## chapter6、浮点数运算

### 加法和减法

- 流程图
- 其中有大量的判断来辅助程序节省运算（如红圈中的significand = 0？return other number ： continue exponents loop）
- 对阶、尾数加减后，如果尾数为0，说明相加的两个数互为相反数。此时要把exponent置0，然后再把结果（+-0）return
- 如果阶码溢出，返回无穷时，要把尾数清0
- 如果在规划化中间结果的时候，发现阶码为全0了，此时即结果变成了非规格化数，此时尾数要右移一位，保证和阶码$2^{-126}$对应。
- 注意：IEEE 754所能表示的最小数为$2^{-149}$，因此当数比此数还小的时候，判作下溢为0

![image-20211009151704055](计算机组织与结构.assets/image-20211009151704055.png)



- 对阶（保证两个阶码是相同的）

  - 原则是把小阶变大，尾数右移（原因是右移的时候可能高位会溢出，造成较大的精度损失）

- 尾数加减

  - 即为定点原码小数的加减运算（**注意：所得结果也是原码！**）
  - $X - Y = X + [Y]_{补}$
    - 若结果产生了进位，表示减法得到的结果和X同号，所得结果即为所求。
    - 若结果没有产生进位，表示减法得到的结果和X异号，得到的是数值为的补码形式，将所得结果求补重新化为绝对值原码形式，并把符号位取反，即得所求。

  

- 尾数规格化

  - 考虑保护位

- 尾数的舍入处理

  - 保护位100采用舍入到偶数
  - 就近舍入
  - 朝正无穷舍入：正数+1，负数舍掉
  - 朝负无穷舍入：正数舍掉，负数-1
  - 朝0舍入：全部舍掉

- 溢出判断

#### 一个栗子

![image-20211009153440887](计算机组织与结构.assets/image-20211009153440887.png)





### 乘法

![image-20211009153249010](计算机组织与结构.assets/image-20211009153249010.png)

如果上溢直接报错，如果下溢的话要先判断是否是非规格化数，然后再判断是否是下溢到0



### 除法

![image-20211009154157680](计算机组织与结构.assets/image-20211009154157680.png)



## chapter7、十进制运算

### 加法

#### 运算方法

![image-20211012165247620](计算机组织与结构.assets/image-20211012165247620.png)

当被加数超过10时，无论是在10 - 16还是16 - 18之间，都应该**+6（0110）进行补偿**

补偿数推导原理

```
x - 10 = y + x -16

x + y - 16 = x - 10

-> y = 6
```

#### 补偿硬件实现

- 模拟一位十进制的加减（四位二进制数）
- S2和S1位下面连的线就是实现+6（0110）的操作
  - 当C4旁边的或门信号为1时，加0110
  - 实现原理
    - C4为1，表示加法的4位结果在16 - 18之间
    - C4为0，但是S3为1，S2和S1至少有一个为1（表现为两个与门）

![image-20211012170007609](计算机组织与结构.assets/image-20211012170007609.png)

### 减法

#### 运算方法

![image-20211012171925932](计算机组织与结构.assets/image-20211012171925932.png)

- 模仿二进制运算，求十进制补码
  - **先十进制“取反”**
    - 第一种方法：先按位反转，再加1010(10)
      - 推导：$9 - x = 15 - x + y - 16 \to \ y = 10$
    - 第一种方法：先加0110(6)，再按位反转
      - 推导：$9 - x = 15 - (x + y) \to \ y = 6$
    - 这里的推导都是基于真值进行的。
  - 然后在最后一位上 + 1
    - 此处直接二进制加就好

##### 栗子

- ![image-20211012173137153](计算机组织与结构.assets/image-20211012173137153.png)

先转十进制补码，然后加，然后按照加法处理的方法看是否需要加

判断减法结果是否需要取反的标志是看是否溢出

- 如果没有溢出，则需要取反（不够还$10^n$）
- 如果溢出了，则够减（还上$10^n$）



## chapter8、内部存储

### 定义

![image-20211014141140766](计算机组织与结构.assets/image-20211014141140766.png)  

- 注：寻址能力的真正含义应该是计算机可识别的存储单元位数。

### 存储器层次结构

![image-20211014142443329](计算机组织与结构.assets/image-20211014142443329.png)

- 越上面表示它越靠近CPU

### 半导体主存储器

- 以半导体芯片作为主存储器是最主流的做法
- 位元（Memory cell）：半导体存储器的基本元件
  - 特性：
    - 呈现两种稳态（获半稳态），分别表示二进制的0和1
    - 至少能被写入数据一次，用来设知状态
    - 能够被读取来获得状态信息

![image-20211014143155447](计算机组织与结构.assets/image-20211014143155447.png)

- 类型

![image-20211014143310431](计算机组织与结构.assets/image-20211014143310431.png)



#### 随机存取存储器

（Random Access Memory）

- 可以简单快速地进行读/写操作
- 易失的（volatile）
- 动态（dynamic）RAM / 静态（static）RAM
- 动态RAM需要刷新

##### DRAM

![image-20211014144201398](计算机组织与结构.assets/image-20211014144201398.png)

##### SRAM

- 静态可以保证不漏电（状态稳定，不需要刷新）

- ![image-20211014144401969](计算机组织与结构.assets/image-20211014144401969.png)

DRAM和SRAM的对比

![image-20211014144925497](计算机组织与结构.assets/image-20211014144925497.png)

##### 更高级的DRAM架构

- 类型
  - 同步DRAM，Synchronous DRAM
  - 双速率SDRAM，Double-Data-Rate SDRAM，DDR SDRAM（DDR）

传统DRAM是异步的，它要等待地址、控制信号、执行功能的延时，等待延时后，才能被读出或写入数据

![image-20211014150828099](计算机组织与结构.assets/image-20211014150828099.png)

- 每个时钟周期发送两次信号
- DDR2、DDR3...等做出的改进主要是缩短每次时钟周期的时间

#### 只读存储器(ROM/PROM)

- 特性
  - 非易失的（nonvolatile），不要求供电维持数据
  - ROM可读（不可以被修改）
- 应用
  - 微程序设计，库子程序，系统程序，函数表，**用于做保存出厂设置的系统盘**
- 问题
  - 固化数据需要较大的固定成本
  - 无出错处理机会：如果有一位出错，则整批ROM芯片只能报废
- ROM在出厂的时候已经写好，后续不可写

#### PROM

Programmable ROM

- 非易失的
- 只能被写入一次
  - 写过程是用电信号执行
  - 需要特殊设备来完成写或“编程”过程
- 好处：可以自己完成写的过程，写完之后仍然不可改
- 与ROM的对比
  - PROM提供了灵活性和方便性
  - ROM在大批量生产领域仍具有吸引力

#### 主要进行读操作的存储器

Read-Mostly Memory

- 特性
  - 读操作比写操作频繁得多
  - 非易失的
- 类型
  - EPROM（尽管命名后缀是ROM，但不是只读的，应该是RMM）
  - EEPROM（同上）
  - Flash memory

##### EPROM

Erasable programmable read-only memory

光可擦除/可编程只读存储器

- 特性
  - 光擦除，电写入
    - 擦除：在写操作之前把封装芯片暴露在紫外线下
      - 所有的存储单元都变回相同的状态
      - 每次擦除需要约20分钟
    - 注：重新写不能直接覆盖已有内容，要先把已有内容清楚再写入
- 和PROM对比
  - EPROM更贵，但它具有可多次改写的优点

##### EEPROM

电可擦除/可编程只读存储器Electrically erasable programmable read-only memory

- 特性
  - 可以随时写入而不删除之前的内容
  - 只更新寻址到的一个或多个字节
  - 写操作每字节需要几百微妙
- 与EPROM对比：
  - EEPROM更贵，且密度低（集成度低），写速度慢，支持小容量芯片

#### 快闪存储器

Flash Memory

- 特性
  - 电可擦除
  - 擦除时间可达几秒，比EPROM快多了
  - 可以在块级擦除，但不能在字节级擦除
  - 达到与EPROM相同的高密度（与EEPROM相比）
- 与EPROM、EEPROM对比
  - 价格和功能介于EPROM和EEPROM之间



### 寻址单元

- 由若干相同地址的位元组成
- 寻址模式
  - Byte
  - Word

cell相当于一个床位，addressable unit相当于一个房间，一个房间共用一个地址

![image-20211021140254107](计算机组织与结构.assets/image-20211021140254107.png)



### 存储阵列

- 大量的寻址单元排在一起
- 某一个寻址单元的确定是由行、列两根寻址线确定

![image-20211014154919637](计算机组织与结构.assets/image-20211014154919637.png)

#### 如何寻址

- 通过地址译码器

#### 如何刷新

即刷新电容，防止电容漏电漏到影响状态的表示

- 集中式刷新
  - 停止读写操作，并刷新每一行
  - 刷新时无法操作内存
- 分散式刷新
  - 在每个存储周期中，当读写操作完成时进行刷新
  - 会增加每个存储周期的时间
- 异步刷新
  - 每一行各自以64ms间隔刷新
  - 效率高：常用

![image-20211021141358269](计算机组织与结构.assets/image-20211021141358269.png)

![image-20211026200557165](计算机组织与结构.assets/image-20211026200557165.png)

👆例题：生成的刷新信号的间隔时间指的是行之间的刷新时间间隔

- 芯片引脚
- 操作芯片、读写内存的接口

如果是刷主存的话，先看芯片是怎么扩展的，位扩展的同时刷，字扩展的异步刷

![image-20211026113333973](计算机组织与结构.assets/image-20211026113333973.png)

### 芯片拓展

- 位扩展：增加寻址单元的位数，即增加一次写入和读出的位数，从4根数据线变为8根
- 地址线决定的是多少行、多少列，即寻址单元的个数
- 字扩展：如果16K * 8bit是7 * 7根地址线，那么64K * 8bit是8 * 8根地址线

![image-20211026113514507](计算机组织与结构.assets/image-20211026113514507.png)

- 黑色芯片焊在绿色内存板上即为内存条
- 在主板上插内存条是字拓展，插槽上组合多个存储模块

#### 

主存地址是27位，片内地址24位，与24位主存地址相同；12位是行号，低12位是列号

而主存的低3位地址是用来选片的，即确定8个字节中的哪一个。

芯片内地址不连续，是交叉编址，可以保证同时读写所有芯片

## chapter9、高速缓存存储器（cache）

![image-20211026114603436](计算机组织与结构.assets/image-20211026114603436.png)

Cache是为了解决**内存墙**的问题：CPU的速度比内存的速度快，且两者差距不断扩大，导致CPU”巧妇难为无米之炊”

### 基本思路

- 解决内存墙带来的CPU和主存协作问题
  - 在使用主存（相对大而慢）之余，添加一块小而快的Cache
  - Cache位于CPU和主存之间，可以集成在CPU内部或作为主板上的一个模块
  - Cache中存放了主存中的部分信息的副本

![image-20211026114935402](计算机组织与结构.assets/image-20211026114935402.png)

### 工作流程

- 检查（Check）：当CPU试图访问主存中的某个字时，首先检查这个字是否在Cache中
- 检查后分两种情况处理
  - **命中（Hit）**：如果在Cache中，则把**这个字**传送给CPU
  - **未命中（Miss）**：如果不在Cache中，则将主存中包含这个字**固定大小的块（block）**读入Cache中，然后再从Cache传送该字给CPU

![image-20211026115806596](计算机组织与结构.assets/image-20211026115806596-16352206869931.png)

#### Hit判断

- 冯诺依曼体系的设计
  - CPU通过**位置**对主存中的内容进行寻址，不关心存储在其中的内容
  - Cache通过**标记（tags）**来标识其内容在主存中的对应**位置**
  - CPU就通过检查标记是否是要访问字节的地址来判断是否Hit

#### 程序访问的局部性原理

（CPU访问主存有规律，导致Cache命中率高）

- 定义
  - 处理器频繁访问主存中相同位置或者相邻存储位置的现象
- 类型
  - **时间局部性**：在相对较短的时间周期内，重复访问特定的信息（也就是访问相同位置的信息）
  - **空间局部性**：在相对较短的时间周期内，访问相邻存储位置的数据
    - **顺序局部性**：当数据被线性排列和访问时，出现的空间局部性的一种特殊情况
      - 例如：遍历一维数组中的元素

- 是相对较短时间周期内的一个统计规律

![image-20211026120949718](计算机组织与结构.assets/image-20211026120949718.png)

#### 向cache传送内容

- 利用“时间局限性”
  - 将未命中的数据在返回给CPU的同时存放在Cache中，以便再次访问时命中

![image-20211026121422693](计算机组织与结构.assets/image-20211026121422693.png)

#### 传送块而不是传送字

- 利用“空间局部性”
  - 将包含所访问的字的块存储到Cache中，以便在访问相邻数据时命中
  - 内存事先已经定义好为一个个块，Cache直接把访问字所属的块搬进来即可
  - 由于Cache是按行存储，然后把要访问的字按块搬入对应的行中，所以事实上CPU访问Cache时是检查字所属块的“块号”是否相符
  - 而块内部的字各自的地址映射排列则自有一套规则

![image-20211026121544812](计算机组织与结构.assets/image-20211026121544812.png)

#### 平均访问时间

check的时间是$T_c$, 从Cache到CPU的时间忽略不计

$T_A = p * T_C + (1-p)* (T_C + T_M)$表示的是两种情况

$T_A = T_C + (1-p)* T_M$表示两个阶段，第一个阶段是check，第二个阶段是访问主存



![image-20211026125334919](计算机组织与结构.assets/image-20211026125334919.png)

### Cache的设计要素

#### Cache容量

- 扩大Cache容量带来的结果
  - 好处：增大了命中率p
  - 坏处：增大了Cache的开销和访问时间$T_C$（Cache本身的集成度和成本不理想）
- 导致当Cache增大到一定程度后，带来的增幅已经不及开销了，所以Cache不是越大越好。

#### 映射功能

- 实现主存块到Cache行的映射
- 有两个标记，块号，块内地址
  - 所有块内的字的地址有着这样的规律：前面的位是一样的（可以作为块号），后面的位不同（可以作为块内地址）
  - 比如：假如一个块有K位，则后$log_2K$表示块内地址
- 映射方式的选择会影响Cache的组织结构



##### 直接映射（Direct mapping）

  - 将主存中的每一个块映射到**一个**固定可用的cache行中
  - 假设i是cache行号，j是主存储器的块号，C是cache的行数
    - $i = j\ mod\ C$（间隔得放，是为了尽可能让连续的块都被载入cache中）

![image-20211109000149999](计算机组织与结构.assets/image-20211109000149999.png)

- Cache中的标记位
  - 标记位必不可少，但是由于占空间，会有成本。所以它越短越好
  - 直接映射到同一行的不同块的低$log_2C$位都是一样的（即行号）
    - 地址中位数最多n位 $n = log_2M - log_2C$（M是块号的长度，C是cache行的数量）
- 例：
  - **块号从0开始编码**
  - 假设cache有4行，每行包含8个字（**cache每行的长度和主存中每个块的长度是一样的**）；主存中包含128个字。访问主存的地址长度为7位，则：
    - 块号一共有 128 / 8 = 16个，因此M = 16
    - 最低的3位：块内地址
    - 中间的2位：映射时所对应的Cache行号
    - 最高的2位：区分映射到同一行的不同块，记录为Cache标记（存在cache标记位里）
- 优点
  - 简单、快速映射、快速检查
- 缺点
  - 抖动现象：如果一个程序重复访问两个需要映射到同一行中且来自不同块的字，则这两个块不断被交换到cache中，cache的命中率降低。
- 适合大容量的cache



##### 关联映射（Associative mapping）

- 一个主存块可以装入cache任意一行
- Cache中的标记位
  - 地址中最高n位 $n = log_2M$
- 例：
  - 假设cache有4行，每行包含8个字（**cache每行的长度和主存中每个块的长度是一样的**）；主存中包含128个字。访问主存的地址长度为7位，则：
    - 块号一共有 128 / 8 = 16个，因此M = 16
    - 最低的3位：块内地址
    - 最高的4位：块号
- 优点
  - 避免抖动
- 缺点
  - 实现起来比较复杂
  - Cache搜索代价很大，即在检查的时候需要去访问Cache的每一行
- 适合容量较小的Cache



##### 组关联映射（Set associative mapping）

- Cache分成若干组，每一组包含相同数量的行，每个主存块被映射到**固定组**的**任意一行**
- 假设s是cache组号，j是主存块号，S是组数
  - $s = j\ mod\ S$
- K - 路相关联映射，K是组里面的行数

- Cache中的标记位
  - 地址中最高n位 $n = log_2M - log_2S$（M是块号的长度，S是组数）
- 例
  - 假设cache有4行，每行包含8个字，分为2组；主存中包含128个字，访问主存的地址长度为7位，则：
    - 最低的3位：块内地址
    - 中间1位：映射时所对应的Cache中的组
    - 最高的3位：区分映射到同一组的不同块，记录为Cache标记（存在cache标记位里）
- 优点
  - 结合了直接映射和关联映射的优点
- 缺点
  - 结合了直接映射和关联映射的缺点
- 面向不同容量的cache作了折中



##### 三种方式的比较

- 如果K = 1，组关联映射等同于直接映射
- 如果K = C，组关联映射等同于关联映射



##### 关联度

- 一个主存块映射到cache中可能存放的位置个数
  - 直接映射：1
  - 关联映射：C
  - 组关联映射：K
- 关联度越低，命中率越低
  - 直接映射的命中率最低，关联映射的命中率最高
- 关联度越低，判断是否命中的时间越短
  - 直接映射的命中时间最短，关联映射的命中时间最长
- 关联度越低，标记所占额外空间开销越小
  - 直接映射的标段最短，关联映射的标记最长



#### 替换算法

- 一旦cache行被占用，当新的数据块装入cache中时，原先存放的数据块将会被替换掉
- 对于直接映射，每个数据块都只有唯一对应的行可以放置，没有选择的机会
- 对于关联映射和组关联映射，每个数据块被允许在多个行中选择一个进行放置，就需要**替换算法**来决定替换哪一行中的数据块
  - 替换算法通过硬件来实现
- 目标：替换最不可能使用的块

##### 最近最少使用算法

（Least Recently Used，LRU）

- 假设：最近使用过的数据块更有可能会被再次使用
- 策略：替换掉在cache中**最长时间未被访问的数据块**

- 实现：2路组关联映射（见教材）
  - 每行包含一个USE位
  - 当同一组中的某行被访问时，将其USE位设为1，同时将另一行的USE位设为0
  - 当将新的数据块读入该组时，替换掉USE位为0的行的数据块

##### 先进先出算法

（First In First Out，FIFO）

- 假设：最近由主存载入Cache的数据块更有可能被使用
- 策略：替换掉在Cache中**停留时间最长的块**
- 实现：时间片轮转法 或 环形缓冲技术
  - 每行包含一个标识位
  - 当同一组中的某行被替换时，将其标识为1，同时将其下一行的标识设为0
    - 如果被替换的是该组中的最后一行，则将该组中的第一行的标识为设为0
  - 当讲新的数据块读入该组时，替换掉标识位为0的行中的数据块

##### 最不经常使用算法

（Last Frequently Used，LFU）

- 假设：访问越频繁的数据块越有可能被再次使用
- 策略：替换掉cache中被访问次数最少的数据块
- 实现：为每一行设置计数器

##### 随机替换算法

（Random）

- 假设：每个数据块被再次使用的可能性是相同的
- 策略：随即替换cache中的数据块
- 实现：随机替换
- 随即替换算法在性能上只稍逊于使用其他替换算法



#### 写策略

- 主存和cache的一致性
  - 当cache中的某个数据块被替换时，需要考虑该数据块是否被修改
- 两种情况
  - 如果没被修改，则该数据块可以直接被替换掉
  - 如果被修改，则在替换掉该数据块之前，必须将修改后的数据块写回到主存中的对应位置

##### 写直达

- 所有写操作都同时对cache和主存进行
- 优点
  - 确保主存中的数据总是和cache中的数据一致，**总是最新的**
- 缺点
  - 产生大量的主存访问，减慢写操作
- 应用场景：在需要确保主存中的数据总是最新的时。比如多个cpu的计算机

##### 写回法

- 先更新cache中的数据，当cache中某个数据块被替换时，如果它被修改了，才写回主存
- 利用一个脏位（dirty bit）或者使用位（use bit）来表示块是否被修改
- 优点
  - 减少了访问主存的次数
- 缺点
  - 部分主存数据可能不是最新的
    - 部分I/O模块存取时可能无法获得最新的数据，为解决该问题会使得电路设计更加复杂且有可能带来性能瓶颈



#### 行大小

- 假设从行的大小为一个字开始，随着行大小的逐步增大，Cache的命中率会增加
  - 数据块中包含了更多周围的数据，每次会有更多的数据作为一个块装入cache中
  - 利用空间局限性
- 当行大小辩的较大之后，继续增大行大小，则cache命中率会下降
  - 当cache容量一定的前提下，较大的行会导致cache中的行数变小，导致装入cache中的数据块数量减少，进而造成数据块被频繁替换
  - 每个数据块中包含的数据在主存中位置变远，被使用的可能性减小
  - 抖动
- 行大小与命中率之间的关系较为复杂



#### Cache数目

##### 一级

- 将cache与处理器置于同一芯片（片内cache）
- 减少处理器在外部总线上的活动，从而减少了执行时间

##### 多级

- 当L1未命中时，减少处理器对总线上DRAM或ROM的访问
- 使用单独的数据路径，代替系统总线在L2缓存和处理器之间传输数据，部分处理器将L2 cache结合到处理器芯片上的

*多级cache平均访问时间的计算，多级cache的原理和好处*



## chapter10、外部存储器

### 存储器层次结构

![image-20211110231946955](计算机组织与结构.assets/image-20211110231946955.png)

### 特性

- 用于存储不经常使用的、数据量较大的信息
- 非易失

### 类型

- 磁盘存储器（magnetic disk）
- 光存储器（optical memory）
- 磁带（magnetic tape）
- U盘（USB flash disk），固态硬盘（solid state disk，SSD）

### 磁盘存储器

- 是由涂有**可磁化材料**的**非磁性材料**（基材）构成的圆形盘片
  - 基材：铝、铝合金、玻璃（现在大部分用的）
  - 玻璃基材的优势
    - 改善磁膜表面的均匀性，提高磁盘的可靠性
    - 显著减少整体表面瑕疵，以帮助减少读写错误
    - 能够支持（磁头）较低的飞行高度（使得磁头的读写面积更大）
    - 更高的硬度，使磁盘转动时更加稳定
    - 更强的抗冲击和抗损伤能力

#### 硬磁盘存储器

##### 结构

![image-20211110233142567](计算机组织与结构.assets/image-20211110233142567.png)

- 磁盘存储器每个盘片表面有一个读写磁头，所有磁头通过机械方式固定在一起，同时移动。
- 在任何时候，所有磁头都位于距磁盘中心等距离的磁道上
- 磁头沿着直径方向来回移动，盘片不断转动
- 轴跟盘片固定，轴转动带动盘片转动

##### 磁头

- 对盘片进行读写操作的装置叫做**磁头**
  - 磁头必须产生或感应足够大的电磁场，以便正确地读写
  - 磁头越窄，离盘片的距离就越近
  - 更高的数据密度需要更窄的磁头和更窄的磁道，这将导致更高的出错风险
  - 温彻斯特磁头（Winchester head）
    - 磁头实际上是一个空气动力箔片，当磁盘静止时，它轻轻地停留在盘片的表面上
    - 旋转圆盘时产生的空气压力足以使箔片上升到盘片表面上方

##### 读写机制

- 在读或写操作期间，磁头静止，而盘片在其下方旋转

- 磁头的数量
  - 单磁头：读写公用同一个磁头（软盘、早期硬盘）
  - 双磁头：使用一个单独的磁头进行读取（当代硬盘）

![image-20211110234127742](计算机组织与结构.assets/image-20211110234127742.png)

- 👆红色圈为读磁头，绿色圈为写磁头

##### 写入机制

- 电流脉冲被发送到写入磁头
- 变化的电流激发出磁场
- 产生的磁性图案被记录在下面的盘片表面上
- 反转电流方向，则记录介质上的磁化方向也会反转

##### 读入机制

- 读取磁头是由一个部分屏蔽的**磁阻（MR）敏感器**组成，其电阻取决于在其下移动的介质的磁化方向
- 电流通过MR敏感器时，通过**电压**信号检测其电阻变化
- MR敏感器允许更高频率的操作，实现更高的存储密度和更快的操作速度

##### 数据组织

- 盘片上的数据组织呈现为一组同心圆环，称为**磁道（track）**
- 数据以**扇区（sector）**的形式传输到磁盘或传出磁盘
  - 每个扇区尽管面积不同，但是数据大小不同
  - 默认值为**512B**
- 相邻磁道之间有**间隙**，相邻的扇区之间也留有间隙
- 磁道的编号是从外往里编号，最外面是0

![image-20211110234639119](计算机组织与结构.assets/image-20211110234639119.png)

- 扇区划分
  - 恒定角速度（CAV）
    - 增大记录在盘片区域上的信息位的间隔，使得磁盘能够以恒定的速度扫描信息
    - 优点：能以磁道号和扇区号直接寻址各个数据块，且数据传输率稳定
    - 缺点：磁盘存储容量收到了最内层磁盘所能实现的最大记录密度的限制（最外围的扇区面积大，内侧扇区面积小，但是数据量相同，因此内侧扇区数据密度大，而外围扇区数据利用少）

![image-20211110234853019](计算机组织与结构.assets/image-20211110234853019.png)

- 扇区划分（续）
  - 多带式记录/多重区域记录
    - 将盘面划分为多个同心圆区域，每个区域中各磁道的扇区数量是相同的，距离中心较远的分区包含的扇区数多于距离中心较近的分区
    - 优点：提升存储容量
    - 缺点：需要更复杂的电路

![image-20211110235208732](计算机组织与结构.assets/image-20211110235208732.png)

- 柱面
  - 所有盘片上处于相同的相对位置的一组磁道被称为**柱面**

![image-20211110235440877](计算机组织与结构.assets/image-20211110235440877.png)

##### 格式化

- 磁道必须有一些起始点和辨别每个扇区起点及终点的方法
- 格式化时，会附有一些仅被磁盘驱动器使用而不被用户存取的额外数据

![image-20211110235633870](计算机组织与结构.assets/image-20211110235633870.png)

- 硬盘不能长时间使用的原因：
  - 长期使用时，导致磁头和磁盘间磨损
- 分为低级格式化和高级格式化
  - 低级：完全清除数据（有损），只能对整个硬盘进行清楚，且对硬盘有损
  - 高级：并没有删除数据，只是把硬盘标记位可使用

##### I/O访问时间

- 寻道时间：磁头定位到所需移动到的磁道所花费的时间

  - 初始启动时间，跨越若干磁道所用的时间
- 旋转延迟：等待响应扇区的起始处到达磁头所需的时间

  - 通常是磁道旋转半周所需的时间
- 传送时间：数据传输所需的时间

![image-20211111110455235](计算机组织与结构.assets/image-20211111110455235.png)



- $\frac{b}{N}$表示大概有多少磁道
- 当跨越磁道时，平均访问时间的计算要考虑寻道时间和旋转延迟

![image-20211111113330546](计算机组织与结构.assets/image-20211111113330546.png)

- 红圈是平均寻道时间 + 平均旋转延迟
- 当连续访问多个相邻的磁道时，跨越磁道：
  - 对于每个磁道都需要考虑旋转延迟，因为不能保证转过去后正好磁头位于需要读取数据的位置
  - 通常只需要考虑第一个磁道的寻道时间，因为在后续的寻道中，所花费的时间几乎可以忽略不计。但在明确知道跨越每个磁道需要的时间时需要考虑

###### 一个栗子

![image-20211111122211078](计算机组织与结构.assets/image-20211111122211078.png)

![image-20211111122312319](计算机组织与结构.assets/image-20211111122312319.png)

- 读500个扇区的时间即为磁头旋转一圈的时间

![image-20211111122519193](计算机组织与结构.assets/image-20211111122519193.png)

- 读1个扇区的时间即为$\frac{4}{500}$

##### 磁头寻道/磁盘调度

- 目标：当有多个访问磁盘任务时，使得平均寻道时间最少
- 常见的磁头寻道/磁盘调度算法
  - 先来先服务（First Come First Service，FCFS）
  - 最短寻道时间优先（Shortest Seek Time First， SSTF）
  - 扫描/电梯（SCAN）
  - 循环扫描（C-SCAN）
  - LOOK
  - C-LOOK

###### 先来先服务（FCFS）

- 按照请求访问磁盘的先后次序进行处理
- 优点：公平简单
- 缺点：如果有大量访问磁盘的任务，且请求访问的磁道很分散，则性能上很差，寻道时间长

![image-20211111123959811](计算机组织与结构.assets/image-20211111123959811.png)

###### 最短寻道时间优先（SSTF）

- 优先处理起始位置与当前磁头位置最接近的读写任务
- 优点：每次的寻道时间最短（局部最优），平均寻道时间缩短
- 缺点：可能产生饥饿现象，尤其是位于两端的磁道请求（被忽略）

![image-20211111124157160](计算机组织与结构.assets/image-20211111124157160.png)

###### 扫描/电梯（SCAN）

- 总是**按照一个方向**进行磁盘调度，直到**该方向上的边缘**，然后改变方向
- 优点：性能较好，平均寻道时间短，不会产生饥饿现象
- 缺点：只有到最边上的磁道才能改变磁头的移动方向，对于各个位置磁道响应频率不平均

![image-20211111124334842](计算机组织与结构.assets/image-20211111124334842.png)

###### 循环扫描（C-SCAN）

- 只有磁头**朝某个确定方向移动时**才会响应请求，移动到边缘后立即让磁头返回起点（此过程磁头的移动速度很快），返回途中不做任何处理
- 优点：与SCAN算法相比，对于各位置磁道的响应频率更平均
- 缺点：与SCAN算法相比，平均寻道时间更长

![image-20211111124700470](计算机组织与结构.assets/image-20211111124700470.png)

###### LOOK

- SCAN算法的升级，只要磁头移动方向上不再有请求就立即改变磁头的方向
- 缺点：对于移动方向上新进来的调度任务不友好

![image-20211111124838097](计算机组织与结构.assets/image-20211111124838097.png)

###### C-LOOK

- C-SCAN算法的改进，只要磁头移动方向上不再有请求就立即改变磁头的方向

![image-20211111125013975](计算机组织与结构.assets/image-20211111125013975.png)



### 光存储器

#### 常见产品

- 光盘（CD）
- 光盘只读存储器（CD-ROM）
- 可刻录光盘（CD-R，recordable）
- 可重写光盘（CD-RW，rewritable）
- 数字多功能光盘（DVD）
- 可刻录DVD（DVD-R）
- 可重写DVD（DVD-RW）
- 高清晰视频光盘（High definition video disk，Blu-Ray DVD）

![image-20211111151202905](计算机组织与结构.assets/image-20211111151202905.png)

#### CD和CD-ROM

- 二者采取类似的技术，但CD-ROM更加耐用且有纠错功能
- 制造方法
  - 用精密聚焦的高强度激光束制造一个母盘
  - 以母盘作为模板压印出聚碳酸酯的复制品（聚碳酸酯类似于一个模板，以母盘按上去）
    - 以母盘从上往下压，下面是聚碳酸酯材料，丙烯酸树脂保护层在上面
    - 激光**从下往上照**
  - 在凹坑表面上镀上一层高反射材料
  - 使用丙烯酸树脂保护高反射材料（防止磨损）
  - 在丙烯酸树脂层上用丝网印刷术印制标签

![image-20211111151123012](计算机组织与结构.assets/image-20211111151123012.png)

##### 读取

- 通过安装在光盘播放器或驱动装置内的低强度激光束从CD或CD-ROM处读取信息
  - 如果激光束照在凹坑（pit）上，由于凹坑表面有些不平，因此光被散射，反射回**低强度**的激光
  - 如果激光束照在台（land）上，台的表面光滑平坦，反射回来的是**高强度**的激光
- 盘片上包含一条**单螺旋的轨道**，轨道上的所有扇区长度相同
  - 盘片**以变速旋转**
  - 凹坑被激光以**恒定线速度**读出（经过扇区的时间是一样的）

![image-20211111151136688](计算机组织与结构.assets/image-20211111151136688.png)

##### 优点

- 存储有信息的光盘可以廉价地进行大规模复制
- 光盘是可更换的

##### 缺点

- 它是只读的，不可更改

- 其存取时间比磁盘存储器长得多

#### CD-R和CD-RW

- CD-R
  - 包含了一个染色层，用于改变反射率，并且有高强度激光激活
  - 生成的盘既能在CD-R驱动器上也能在CD-ROM驱动器上读出

![image-20211111151102403](计算机组织与结构.assets/image-20211111151102403.png)

#### DVD（数字多功能光盘）

- DVD vs CD
  - DVD上的为组装更紧密：光道间隙，凹坑间距均更小（容量达4.7GB）
  - DVD采用双层结构：设有半反射层，可以通过调整焦距读取每一层（容量达到8.5GB）
  - DVD-ROM可以用两面记录数据（容量达到17GB）（而不是一面印标签一面装数据）
- DVD-R和DVD-RW

#### 高清晰光盘（Blu-Ray DVD）

- 通过使用更短波长的激光（在蓝-紫光范围），可以实现更高的位密度（数据凹坑相对更小）

![image-20211111151231996](计算机组织与结构.assets/image-20211111151231996.png)

#### 磁带

- 使用与磁盘类似的记录和读取技术
- 记录
  - 介质是柔韧的聚酯薄膜带，外涂磁性材料
- 读取
  - 磁带：顺序读取（sequential-access）- 先把需要读取数据前面的部分滚完
    - 磁盘：直接读取（direct-access）- 磁头直接到达需要读取数据的位置
  - 并行记录 vs 串行记录（蛇形记录）

![image-20211111151244900](计算机组织与结构.assets/image-20211111151244900.png)



### 快闪存储器

![image-20211111151032284](计算机组织与结构.assets/image-20211111151032284.png)

### U盘

- 采用快闪存储器，属于非易失性半导体存储器
- 相比于软盘和光盘：体积小，容量大，携带方便，寿命长达数年

### 固态硬盘

- 与U盘没有本质区别：容量更大，存储性能更好
- 与硬磁盘存储器相比：抗振性好，无噪声，能耗低，发热量低

### 总结

![image-20211111151505663](计算机组织与结构.assets/image-20211111151505663.png)

## chapter11、冗余磁盘阵列（RAID）

### 分类

![image-20211122193859188](计算机组织与结构.assets/image-20211122193859188.png)

### 定义、基本思想及特性

- 冗余磁盘阵列/独立磁盘冗余阵列：Redundant Arrays of independent Disks（RAID）
- 基本思想
  - 将多个独立操作的磁盘按某种方式组织成磁盘阵列，以增加容量
    - 物理上多个磁盘组成一组，但逻辑上只有一个磁盘
  - 将数据存储在多个盘体上，通过这些盘并行工作来提高数据传输率
  - 采用数据冗余来进行错误恢复以提高系统可靠性
- 特性
  - 由一组物理磁盘驱动器组成，被视为单个的逻辑驱动器
  - 数据是分布在多个物理磁盘上
  - 冗余磁盘容量用于存储校验信息，保证磁盘万一损坏时能恢复数据

### RAID 0

- 数据以条带的形式在可用的磁盘上分布
- 不采用冗余来改善性能（不是RAID家族中的真正成员）
- 用途
  - 高数据传输率
    - 四个硬盘同时传输数据
  - 高速响应I/O请求
    - 两个I/O请求所需要的数据块可能在不同的磁盘上，RAID 0机制可以让两个物理磁盘同时响应

![image-20211122193923305](计算机组织与结构.assets/image-20211122193923305.png)

![image-20211122193952074](计算机组织与结构.assets/image-20211122193952074.png)

### RAID 1

- 采用了数据条带
- 采用简单地备份所有数据的方法来实现冗余
- 优点：
  - 因为有备份盘，所以在有些时候（备份盘和数据盘同时输出）可以比RAID 0更加高速得响应I/O请求
  - 高速响应I/O请求：即便是同一个磁盘上的数据块，也可以由两组磁盘分别响应
  - 读请求可以由包含请求数据的两个对应磁盘中的某一个提供服务，可以选择寻道时间较小的那个
  - 写请求需要更新两个对应的条带：可以并行完成，但受限于写入较慢的磁盘
  - 单个磁盘损坏时不会影响数据访问，恢复受损磁盘简单
- 缺点：
  - 写时，备份盘和数据盘均需要写入，速度慢
  - 价格昂贵
- 用途
  - 只限于用在存储系统软件、数据和其他关键文件的驱动器中
- 和RAID 0相比
  - 如果有大批的读请求，则RAID 1能实现高速的I/O速率，性能可以达到RAID 0的两倍
  - 如果I/O请求有相当大的部分是写需求，则它不比RAID 0的性能好多少

![image-20211122194007396](计算机组织与结构.assets/image-20211122194007396.png)

#### RAID 01 vs RAID 10

- RAID 01 = RAID 0+1：先做RAID 0，再做RAID 1
- RAID 10 = RAID 1+0：先做RAID 1，再做RAID 0
- 两者在数据传输率和磁盘利用率上没有明显区别，主要区别是对磁盘损坏的容错能力

![image-20211122194017829](计算机组织与结构.assets/image-20211122194017829.png)

### RAID 2

- 采用并行存取技术
- 目标
  - **所有**磁盘都参与**每个**I/O请求的执行
- 特点
  - 各个驱动器的轴是同步旋转的，因此每个磁盘上的每个磁头在任何时刻都位于同一位置
  - 采用数据条带：条带非常小，经常只有一个字节或一个字
- 纠错
  - 对于同一条带的各个数据盘上的数据位计算校验码（通常采用海明码），校验码存储在该条带中多个校验盘的对应位置
  - 即**4**个数据盘 + **3**个校验盘（海明码）
- 访问
  - 读取：获取请求的数据和对应的校验码
  - 写入：所有的数据盘和校验盘都被访问
    - **读的时候一起读，写的时候一起写**
- 缺点
  - 冗余盘（校验盘）仍然较多，价格较贵
  - 适用于多磁盘**易出错环境**，对于单个磁盘和磁盘驱动器已经具备高可靠性的情况没有意义

![image-20211122194027347](计算机组织与结构.assets/image-20211122194027347.png)

### RAID 3

- 采用并行存取技术
  - 各个驱动器的轴同步旋转
  - 采用非常小的数据条带
- 对所有数据盘上同一位置的数据计算**奇偶校验码**
  - 当某一磁盘损坏时，可以用于重构数据
    - $P(b)$是校验盘的数据

$$
b_0 = P(b) \bigoplus b_1 \bigoplus b_2 \bigoplus b_3
$$

- 奇偶校验码不能检验出哪位出错了，当已知磁盘损坏时，出错的定位工作已经完成，故可以用奇偶校验码才进行修正。
- 优点
  - 能够获得非常高的数据传输率
    - 对于大量传送，性能改善特别明显
- 缺点
  - 一次只能执行一个I/O请求

![image-20211122194051492](计算机组织与结构.assets/image-20211122194051492.png)

### RAID 4

- 为了解决快速响应多个I/O请求的问题
- 采用独立存取技术
  - 每个磁盘成员的操作是独立的，各个I/O请求能够并行处理
- 采用较大的数据条带？？
- 根据各个数据盘上的数据来逐位计算奇偶校验码，存取在奇偶校验盘上
- 性能
  - 当执行较小规模的I/O写请求时，RAID 4会遭遇写损失
    - 对于每一次写操作，阵列管理软件不仅要修改用户数据，而且要修改相应的校验位
    - 公式：消掉原来的被修改数据，异或上新的数据

$$
P^{'}(B) = P(B) \bigoplus B_0 \bigoplus B_0^{'}
$$

- 当涉及所有磁盘的数据条带的较大I/O写操作时，只要用新的数据位来进行简单的计算即可得到奇偶校验位

  （写入数据大到覆盖硬盘所有条带，所以只需要直接用新数据计算校验码即可）

- 每一次写操作必须涉及到唯一的校验盘，**校验盘会成为瓶颈**

![image-20211122194101218](计算机组织与结构.assets/image-20211122194101218.png)

### RAID 5

- 与RAID 4组织方式相似
- 在所有磁盘上都分布了奇偶校验条带
  - 避免潜在的I/O瓶颈问题
- 访问时的“两读两写”
  - $P(B)和B_0读的顺序没有限制，可以同时读，P^{'}(B)和B^{'}写的顺序也没有限制，也可以同时写，不过需要保证所有的读在写的前面$

$$
P^{'}(B) = P(B) \bigoplus B_0 \bigoplus B_0^{'}
$$

- 所以两读两写最快的时间是2t，最慢是4t

![image-20211122194110376](计算机组织与结构.assets/image-20211122194110376.png)

#### RAID 50

- 先做RAID5，再作RAID 0，也就是对多组RAID5彼此构成条带访问
- RAID 50在底层的任一组或多组RAID 5中出现1颗硬盘损坏时，仍能维持运作；如果任一组RAID 5中出现2颗或2颗以上硬盘损毁，整组RAID 50就会失效
- RAID 50由于在上层把多组RAID 5进行条带化，性能比其单纯的RAID 5高，但容量利用率比RAID 5低

![image-20211122194122235](计算机组织与结构.assets/image-20211122194122235.png)

### RAID 6

- 采用两种不同的校验码，并将校验码以分开的块存于不同的磁盘中
- 优点
  - 提升数据可用性：只有在平均修复时间间隔内3个磁盘都出了故障，才hi造成数据丢失
- 缺点：
  - 写损失：每次写都要影响两个校验块

![image-20211122194324899](计算机组织与结构.assets/image-20211122194324899.png)

### 总结

![image-20211122194358599](计算机组织与结构.assets/image-20211122194358599.png)

## chapter12、虚拟存储器

### 操作系统

- 一种控制应用程序运行和在计算机用户与计算机硬件之间提供接口的程序
- 目标
  - 使计算机使用起来更方便
  - 允许计算机系统的资源以有效的方式使用

![image-20211129101355654](计算机组织与结构.assets/image-20211129101355654.png)

- 早期计算机的主存仅包含系统软件和一个用户程序
  - **单道程序设计**：内存一次只能允许一个程序进行运行，在这次程序运行结束前，其它程序不允许使用内存。
- 现在计算机的主存中包含操作系统和若干个用户程序
  - 当所有任务都需要等待I/O时，**为了避免处理器处于空闲状态**，需要尽可能让更多的任务进入主存
  - **多道程序设计**：让处理器一次处理多个任务，提高处理器的利用率
- 存储器管理
  - 在多道程序系统中，主存需要进一步划分给多个任务，划分的任务由操作系统动态执行
  - 这里不考虑“进程”这一概念



### 如何将更多任务装入主存

- 增大主存容量

- 使用交换（exchange）技术
  - 当主存中没有处于就绪的任务时，操作系统调入其他任务来执行
  - 两种交换技术
    - 分区（partitioning）和分页（paging）
  
- 虚拟存储器
  - 请求分页：每次访问仅将当前需要的页面调入主存，而其他不活跃的页面放在外存磁盘上
  - 虚拟地址
  
  

### 分区方式

- 分区方式将主存分为两大区域	

  - 系统区：固定的地址范围内，存放操作系统
  - 用户区：存放所有用户程序


#### 简单固定分区

  - 用户区划分为**长度不等的固定长**的分区
  - 当一个任务调入主存时，分配一个可用的（一个区只能放一个任务）、能容纳它的、最小的分区
  - 优点：简单
  - 缺点：浪费主存空间

![image-20211129101413437](计算机组织与结构.assets/image-20211129101413437.png)

#### 可变长分区

- 用户区按每个人物所需要的内存大小进行分配
- 优点：提高了主存的利用率
- 缺点：时间越长，存储器中的**碎片**（分散不连续的内存空闲空间）就越多

![image-20211129101500521](计算机组织与结构.assets/image-20211129101500521.png)

### 分页方式

#### 基本思想

- 把主存分为固定长且比较小的存储块，称为**页框**（page frame），每个任务也被划分成固定长的程序块，称为**页**（page）
  - 理论依据：同一个任务的页不需要在内存中连续存储
- 将页装入页框中，且无需采用 连续的页框来存放一个任务中所有的页
- 逻辑地址：指令中的地址
- 物理地址：实际主存地址

![image-20211129101512948](计算机组织与结构.assets/image-20211129101512948.png)

### 虚拟存储器

- 问题
  - 内存的大小是有限的，但对内存的需求不断增加
- 基本思想
  - **请求分页**：仅将当前需要的页面调入主存
    - 通过硬件将逻辑地址转换为物理地址
    - **未命中**时在主存和硬盘之间交换信息
- 优点
  - 在不扩大物理内存的前提下，可以载入更多的任务
  - 编写程序时不需要考虑可用物理内存的状态
    - 程序员认为可以独享一个连续的、很大的内存
  - 可以在大于物理内存的逻辑地址空间中编程

- 流程
- ![image-20211129101548292](计算机组织与结构.assets/image-20211129101548292.png)
- 设计中遇到的问题
  - 页大小
    - 4KB、8KB、...
  - 映射算法
    - 全相联映射
  - 写策略
    - 写回
  - 类型
    - 分页式虚拟存储器
    - 分段式虚拟存储器
    - 段页式虚拟存储器 

#### 分页式虚拟存储器

- 主存储器和虚拟地址空间都被划分为大小相等的页面
  - 虚拟页（virtual page，**VP**）/ 逻辑页（logical page）：虚拟地址空间中的页面
  - 物理页（physical page，**PP**）/ 页框（page frame）：主存空间中的页面
- 页表
  - 页表中包含了**所有虚拟页**的信息，包括虚拟页的存放位置、装入位（valid）、修改位（dirty）、存取权限为等等
  - 保存在主存中
  - 虚拟地址
    - **虚拟页号  + 页内偏移量**

![image-20211129101608528](计算机组织与结构.assets/image-20211129101608528.png)

![image-20211129101638527](计算机组织与结构.assets/image-20211129101638527.png)



#### 页表

- 根据页表中记录的物理页存放位置，可以将虚拟地址转化为物理地址

- 页表中的“存放位置”统一为PP的长度，其中可能存放的状态有3种
- VP号不会存入页表中，因为根据页表的行号对应找即可找到需要的VP号



- **对于某一个字节而言，它在页表中有 *虚拟页号 + 页面偏移量*，在主存中有 *物理页号 + 页面偏移量***



#### 快表

- Translation Lookaside Buffer TLB
- 页表的使用增加了主存的访问次数（页表在主存里）
- 为了减少访存次数，把页表中最活跃的几个页表项（一行一行的）复制到高速缓存中
- 后备转换缓冲器（简称“快表”）：将页表项放入高速缓存中
  - 映射：关联映射、组关联映射
  - 替换：随机替换
- 主存中的页表相应地称之为“慢表”

![image-20211129101924380](计算机组织与结构.assets/image-20211129101924380.png)



##### TLB、页表、Cache的缺失组合

![image-20211129101712514](计算机组织与结构.assets/image-20211129101712514.png)

#### 分段式虚拟存储器

- 将程序和数据分成不同长度的段，将所需的段加载到内存中
- 虚拟地址：段号 + 段内偏移量
- 与分页式虚拟存储器相比
  - 分页式虚拟存储器
    - 优点：实现简单，开销小
    - 缺点：一个数据..
  - 分段式虚拟存储器
    - 优点：
    - 缺点：

#### 段页式虚拟存储器

- 将程序和数据分段，段内再进行分页
  - 每个分段都有一个页表
- 虚拟地址
  - 段号 + 页号 + 页内偏移量
- 优点
  - 程序按段实现共享和保护
- 缺点
  - 需要多次查询



## chapter13、总线

### 回顾

- 总线是连接两个或多个设备的
- 目的是为了简化计算机各个组成部件的互连复杂问题
- 数据传输类型
  - 控制线
  - 地址线
  - 数据线

### 类型

- 芯片内部总线
  - 连接芯片内部的各个部分
    - 例：CPU中连接寄存器、ALU等部分
- **系统总线**（主要讲）
  - 连接CPU、存储器、IO控制器和其他功能设备

![image-20211207174707666](计算机组织与结构.assets/image-20211207174707666.png)

- 通信总线
  - 连接主机和IO设备，或连接不同的计算机系统

### 定义

- 数据线
  - 在系统组件之间传输数据
    - 数据线的数量决定了一次可以传输的数据的大小（一根线只能传输1位）
- 地址线
  - 在数据线和地址IO端口上指定数据的来源和去向
    - 地址线的数量决定了寻址空间的大小（16根地址线的寻址空间是$2^{16}$）
    - 有时候地址可以分两次传（分时复用），寻址空间比地址线的数量大
- 控制线
  - 控制对数据线和地址线的存取和使用

![image-20211207174720780](计算机组织与结构.assets/image-20211207174720780.png)

### 总线数据传输的特点

- 总线可以被多个设备监听，但同一时刻只能由一个**设备**发送数据
  - 如果同一时刻多个设备同时发送数据，会造成数据之间的混淆
  - 使用总线进行数据传输
    - 如果连在总线上的某个设备希望向另一个设备**发送数据**，需要：
      - **获得总线的使用权**
      - 通过总线传送数据
    - 如果连在总线上的某个设备希望向另一个组件**请求数据**，需要：
      - **获得总线的使用权**
      - 通过总线向另一个设备发送请求，等待另一个设备发送数据
- 当总线在被使用过程中，其他设备不可以抢占



### 设计要素

- 用途
  - 专用总线，复用总线
- 仲裁（arbitration）
  - 集中式，分布式
- 时序（timing）
  - 同步、异步、半同步、分离事务
- 总线带宽



#### 用途

- 专用（dedicated）总线：始终只负责一项功能，或始终分配给特定的计算机组件
  - 优点：高吞吐量，减少总线冲突
  - 缺点：增加了系统的规模成本
- 复用（multiplexed）总线：将同一线路用于多种用途
  - 优点：使用的布线数量少，节省空间和成本
  - 缺点：每个模块需要更复杂的控制电路，且共享可能会降低性能

#### 仲裁

- 总线仲裁
  - 当多个设备需要与总线通信时，需要通过策略选择一个设备
- 平衡因素
  - 优先级：优先级高的设备优先被服务
  - 公平性：优先级最低的设备不能一直被延迟
    - 两者之间需要取得平衡

##### 集中式

- 由仲裁器（arbiter）或总线控制器（bus controller）负责分配总线使用权
  - 链式查询 / 菊花链（daisy chain）
  - 计数器查询（query by a counter）
  - 独立请求（independently request）

###### 链式查询

- 所有的设备都是**串行连接**的，并将允许信号从优先级最高的设备下发到优先级最低的设备
- 总线仲裁器收到请求后，在总线**不忙**的前提下，发起允许信号（是一个设备一个设备的传）
  - 如果该设备不打算使用总线，就会传递允许信号
  - 否则使用总线，将总线设置为繁忙状态
- 如果某个设备收到了允许信号并且发送了总线请求，该设备将总线设置为**繁忙状态**，允许信号将不再被进一步传递
  - 优点
    - 确定优先级简单
    - 可以灵活地添加设备
  - 缺点
    - 不能保证公平性（优先级最低的设备很难拿到总线的允许信号）
    - 对电路故障敏感（因为是串行连接）
    - 限制总线的速度（因为是串行，需要一个个查询，类似单线程）

![image-20211207174737394](计算机组织与结构.assets/image-20211207174737394.png)



###### 计数器查询

- 将总线允许线替换为**设备ID线**
- 如果总线空闲，总线仲裁器通过设备ID发送计数
- 如果**当前发送请求**的设备ID等于裁决器当前的计数，裁决器将停止计数，设备将总线设置为忙
  - 优点
    - 通过使用不同的初始计数，可以灵活地确定设备优先级
      - 强调优先级：从1开始（和链式是一样的）
      - 强调公平性：从下一个设备的ID开始
    - 对电路故障不敏感
  - 缺点
    - 需要添加设备ID线
    - 需要解码和比较设备ID信号
    - 限制总线速度（因为是串行，需要一个个查询，类似单线程）

![image-20211207174745798](计算机组织与结构.assets/image-20211207174745798.png)



###### 独立请求

- 每个设备都有自己的总线请求线和总线允许线
- 当一个设备请求总线时，它通过总线请求将请求信号发送给总线仲裁器
- 总线仲裁器决定哪个设备可以使用总线
  - 确定策略：固定优先级，公平链式，LRU，FIFO，...
  - 优点
    - 快速响应
    - 可编程的优先级
  - 缺点
    - 复杂的控制逻辑
    - 更多的控制线路

![image-20211207174756070](计算机组织与结构.assets/image-20211207174756070.png)



##### 分布式

- 每个设备都包含访问控制逻辑，各设备共同作用分享总线
  - 自举式
  - 冲突检测

###### 自举式

- 固定优先级
- 每个设备在其总线请求线上发送请求
  - 最低优先级的设备没有请求线
- 每个设备自行判断自己是否在请求总线的设备中优先级最高
  - 优先级越低的设备越需要监听更多的总线（方向向下的箭头）
  - 优先级越高的设备越不需要箭头，它只需要发送使用请求即可（方向向上的箭头）

![image-20211207174808135](计算机组织与结构.assets/image-20211207174808135.png)



###### 冲突检测

- 当一个设备想使用总线时，它会检查总线是否繁忙
  - 如果总线空闲，设备使用总线
- 冲突：如果两个设备发现总线空闲，它们可能同时使用总线
  - 在传输数据时，设备会监听总线，检查是否存在冲突
  - 如果发生冲突，所有使用总线的设备将停止数据传输，并分别在随机间隔时间后再次请求总线



#### 时序

- 确定每个总线事务的开始和结束时间

  - 总线事务：地址 + 数据 + ... + 数据

##### **同步时序**

  - 优点
    - 更容易实现和测试
  - 缺点
    - 所有设备共享同一个时钟（快的设备要迁就慢的设备）
    - 总线长度受到时钟偏差的限制

![image-20211207174834416](计算机组织与结构.assets/image-20211207174834416.png)



##### **异步时序**

  - 握手策略
    - 非互锁
      - 双方其实没什么限制，是自然的先后关系
    - 半互锁
      - 防止Ready信号一直等，而不撤
    - 全互锁
      - 防止Ack信号在通知Ready信号撤之前就撤了
  - 优点
    - 可以灵活地协调速度不同的设备（相对于同步而言）
  - 缺点
    - 接口逻辑复杂
    - 对噪声**敏感**

![image-20211207174853387](计算机组织与结构.assets/image-20211207174853387.png)

![image-20211207231154047](计算机组织与结构.assets/image-20211207231154047.png)



##### **半同步时序**

  - 为了减少噪声的影响，在异步计时中使用时钟
    - 准备和响应信号在时钟上升沿有效
  - 结合同步和异步定时的优点

![image-20211207231204258](计算机组织与结构.assets/image-20211207231204258.png)



##### 总线层次结构

- 单总线结构
  - CPU、存储器和I/O模块都连接到一条系统总线
  - 优点：简单、易扩展
  - 缺点：
    - 连接的设备越多，总线长度越大，传输延迟也就越大
    - 聚集的传输请求接近总线容量时，总线成为瓶颈
- 双总线结构 Ⅰ
  - 在**CPU**和**存储器**中间增加一个**存储器总线**
  - 优点：增加CPU和存储器之间的传输效率，同时降低系统总线的负担
- 双总线结构 Ⅱ

  - 将系统总线分为存储器总线、I/O总线和IOP
  - 优点：降低I/O对总线的负担
- 多总线结构 Ⅰ

  - 增加了一个 **本地总线（local bus）** 来连接CPU和cache
  - 优点：分离了CPU和I/O的交互
- 多总线结构 Ⅱ

  - 将系统总线分存储器总线、I/O总线和**DMA总线**（连接主存和高速I/O）
  - 优点：增加I/O效率
- 多总线结构 Ⅲ
  - 增加一个 **高速I/O**总线来连接
  - ？？？？




#### 分离事务

- 将一个总线事件分离为两个过程
- 优点：增加总线利用率
- 缺点：增加每个总线事件的持续时间和系统复杂度

![image-20211207231219890](计算机组织与结构.assets/image-20211207231219890.png)

#### 总线带宽和数据传输率（考点）

- 总线带宽（bus bandwith）：总线的**最大数据传输速率**

  - 不要考虑总线仲裁、地址传输等因素
  - 理想情况

- 数据传输速率

  - 考虑地址传输、握手等因素
  - 现实情况

- 总线宽度（bus width）：组成总线的线数

  - 数据总线越宽，一次传输的数据位数就越多
  - 地址总线越宽，一次传输的地址位数就越多

  

### 例题

1. 求同步总线和异步总线的数据传输速率

  - 注意同步总线中 一个时钟周期只能开始一个任务，在时钟周期还没结束的时候不能开始新的任务

![image-20211207231238872](计算机组织与结构.assets/image-20211207231238872.png)

![image-20211207231253010](计算机组织与结构.assets/image-20211207231253010.png)

![image-20211207231301665](计算机组织与结构.assets/image-20211207231301665.png)

2. 不同数据块大小的数据传输率

![image-20211207231312478](计算机组织与结构.assets/image-20211207231312478.png)

![image-20211207231319329](计算机组织与结构.assets/image-20211207231319329.png)

![image-20211207231326229](计算机组织与结构.assets/image-20211207231326229.png)



### 提高总线的数据传输率

- 提高时钟频率
- 增加数据总线宽度
  - 每次**传输更多的数据**（成本：更多的总线线路）
- 块传输
  - 传输一次地址就传输一块数据（成本：高复杂性）
- 分离总线事务
  - 减少**总线空闲时间**（成本：复杂性高，增加每个事务的持续时间）
- 分离地址线和数据线
  - 同时传输地址和数据（成本：更多的总线线路）



## chapter14、指令系统

- 计算机的基本功能是执行程序
- 程序由存储在内存中的一组指令组成
- CPU通过执行指定的指令来完成实际工作



### 指令集

- CPU能执行的各种不同指令的集合

### 要素

- 操作码：指定将要完成的操作
- 源操作数引用
- 结果操作数引用
- 下一条指令引用

### 表示

- 在计算机内部，指令由一个位串来表示
- 指令格式：对于指令的各要素，这个位串划分为几个字段
  - 大多数指令集使用不止一种指令格式
- 机器指令符号表示法
  - 操作码被缩写成助记符来表示
    - ADD，SUB...
  - 操作数也可以用符号来表示
    - 用寄存器编号或内存地址替换操作数

### 操作码

- 不同的计算机上操作码的数目变动是很大的
- 所有计算机上都会存在相同的常用操作类型

#### 逻辑运算

- 逻辑移：补0
- 算术移：符号位不动

#### 控制转移

- 把将要执行的下一条指令的地址作为它的操作数之一
- 过程调用指令：
  - 涉及由目前位置转移到过程的调用指令和由过程返回到调用发生位置的返回指令（如call和ret）
  - 每个过程的开始存储调用者的返回地址
    - $$X \leftarrow PC + \delta; PC \leftarrow X + 1$$
    - 可以支持多重嵌套调用
    - 但是不支持递归调用，会覆盖开头处的返回地址
  - 使用栈

### 操作数

#### 地址

- 一个指令需要有4个地址引用：2个源操作数，1个目的操作数，以及下一条指令地址
  - 下一条指令地址是隐含的
- 地址数量
  - 每条指令中的地址数目越少
    - 指令的长度越短，不需要复杂的CPU
    - 使程序总的指令条数更多，导致执行时间更长，程序也更长更复杂
  - 对于多地址指令，普遍具有多个通用寄存器可用，允许某些运算只使用寄存器即可完成，从而使执行加快

#### 逻辑数据

- 将一个n位单元看作n个1位组成的

#### 大端和小端

大端：高位存在低地址，低位放在高地址

小端：高位存在高地址，低位放在低地址

- 单字节内部还是小端排序（自然朴素的按照书写顺序排）

### 寻址方式

- 记号
  - ![image-20211212215044435](计算机组织与结构.assets/image-20211212215044435.png)

#### 立即寻址

- 方式：操作数实际出现在指令中

- 用法：定义和使用常数或设置变量的初始值

- 算法：操作数 = A

- 优点：除了取指令之外，获得操作数不要求另外的存储器访问

- 缺点：数的大小受限于地址字段的长度

  ![image-20211212215326606](计算机组织与结构.assets/image-20211212215326606.png)

#### 直接寻址

- 方式：地址字段含有操作数的有效地址

- 用法：早期计算机常用，在当代计算机体系结构中不多见

- 算法：EA = A

- 优点：只要求1次存储器访问

- 缺点：有限的地址空间

  ![image-20211212215331622](计算机组织与结构.assets/image-20211212215331622.png)

#### 间接寻址

- 方式：地址字段指示一个存储器字地址，而此地址处保存有操作数的全长度地址
- 算法：EA = (A) ：EA是操作数的有效地址
- 优点：扩大了地址空间
- 缺点：取操作数需要2次访问存储器
- 解释：地址引用的数量限制可能是有益的 ： ？？？

![image-20211212215358457](计算机组织与结构.assets/image-20211212215358457.png)

#### 寄存器寻址

- 方式：地址字段指示的是寄存器
- 算法：EA = R **注意：此处操作数就是寄存器里存的数**
- 优点：指令中仅需要一个较小的地址字段，且不需要存储器访问
- 缺点：地址空间十分有限
- 解释：寄存器寻址只有在被有效使用的时候才更有意义：？？？

![image-20211212215417264](计算机组织与结构.assets/image-20211212215417264.png)

#### 寄存器间接寻址

- 方式：地址字段指示寄存器
- 算法：EA = (R)
- 优点：扩大了地址空间，比间接寻址少1次存储器访问
- 缺点：相对于寄存器寻址，需要多1次存储器访问

![image-20211212215426338](计算机组织与结构.assets/image-20211212215426338.png)

#### 偏移寻址

- 方式：结合直接寻址和寄存器间接寻址能力
- 算法：EA = (R) + A
- 类型
  - 相对寻址
  - 基址寄存器寻址
  - 变址
- 解释：偏移寻址要求指令有两个地址字段，至少其中一个是显式的

![image-20211212215455329](计算机组织与结构.assets/image-20211212215455329.png)

##### 相对寻址

- 方式：隐含引用的寄存器是PC
  - 此指令后续的下一条指令的地址加上地址字段的值产生有效地址
- 用法：大多数存储器访问都相对靠近正在执行的指令，相对寻址可节省指令中的地址位数
- 算法：EA = (PC) + A
- 优点：利用程序局部性原理，节省指令中地址的位数

##### 基址寄存器寻址

- 方式：被引用的寄存器含有一个存储器地址（基地址），地址字段含有一个相对于那个地址的偏移量（操作数是offset）（通常是无符号整数表示）
  - 寄存器引用可以是显示的，也可以是隐式的
- 算法：EA = （BR）+ A
  - BR是基址寄存器
- 用法：虚拟内存空间中的程序重定位

##### 变址寻址

- 方式：指令地址字段引用一个主存地址（基址），被引用的寄存器含有对于该地址的一个正的偏移量（offset）
- 算法：EA = A + （R）
- 用法：为完成重复操作提供一种高效机制
- 扩展：结合间接选址和变址寻址
  - 前变址：EA = （A + （R））
  - 后变址：EA = （A） + （R）

- **与基址寻址的不同**：变址寄存器的内容可以改变（作为offset），而形式地址A保持不变（作为基址）
  - 这样可以保证指令不变，只改变寄存器的值达到访存的目的


#### 栈寻址

- 方式：栈指针保存在寄存器中，对寄存器中栈位置的访问实际上是一种寄存器间接寻址方式
- 解释：与栈相关的是一个指针，它的值是栈顶地址，或者当栈顶 的两个元素已在CPU寄存器内，此时栈顶指针指向栈顶的第三个元素

![image-20211212215902474](计算机组织与结构.assets/image-20211212215902474.png)

栈的应用:???



### 指令格式

![image-20211212215912014](计算机组织与结构.assets/image-20211212215912014.png)

#### 设计原则

![image-20211212215927879](计算机组织与结构.assets/image-20211212215927879.png)

##### 指令长度

- 最明显的权衡考虑是在强有力的指令清单和节省空间之间进行
  - 编程人员希望更多的操作码、操作数、更多的寻址方式和更大的地址范围
  - 指令长度变短可以节省存储空间和减少数据传送时间
- 指令长度应该是字符长度或定点数长度的整数倍
- 指令长度应该等于存储器的传送长度（即数据总线宽度），或这两个值其中之一是另一个的整数倍

##### 位的分配

![image-20211212215942388](计算机组织与结构.assets/image-20211212215942388.png)

##### 变长指令

![image-20211212215947855](计算机组织与结构.assets/image-20211212215947855.png)

##### 指令集设计

![image-20211212215957950](计算机组织与结构.assets/image-20211212215957950.png)

![image-20211212220004660](计算机组织与结构.assets/image-20211212220004660.png)

## chapter15、指令周期和指令流水线

### 指令周期

#### 定义

- 处理单个指令的过程
  - 取指周期：从内存中提取一条指令
  - 执行周期：执行所提取的指令
- 只有当**机器关闭**、发生某种**不可恢复的错误**或遇到停止计算机的程序指令时，程序执行才会停止。

![image-20211212214536649](计算机组织与结构.assets/image-20211212214536649.png)

#### 状态图

- ![image-20211212214549017](计算机组织与结构.assets/image-20211212214549017.png)
- ![image-20211212214600001](计算机组织与结构.assets/image-20211212214600001.png)
- ![image-20211212214606750](计算机组织与结构.assets/image-20211212214606750.png)
- 带中断的指令周期中，还需要**检查有无中断和处理终端，**且自身的执行收到中断的约束。

### 间址周期

- 指令的执行可能涉及一个或多个存储器中的操作数，它们每个都要求一次存储器访问
- 使用间接寻址，还需要额外的存储器访问
- **间址周期**：把间接地址的读取看成是一个额外的指令子周期

![image-20211212214613883](计算机组织与结构.assets/image-20211212214613883.png)

![image-20211212214623179](计算机组织与结构.assets/image-20211212214623179.png)

### CPU的任务

- 取指令：CPU必须从存储器（寄存器、cache、主存）读取指令
- 解释指令：必须对指令进行译码，以确定所要求的动作
- 取数据：指令的执行可能要求从**存储器**或**I/O模块**中读取数据
- 处理数据：指令的执行可能要求对数据完成某些算术或逻辑运算
- 写数据：指令执行的结果可能要写入**存储器**或**I/O模块**中

#### CPU的需求

- 在指令周期中临时保存指令和数据
- 记录当前所执行指令的位置，以便知道下一条指令的位置
  - **CPU需要一些小容量的内部存储器！**

*Basically·*

- 存储地址寄存器（MAR）
- 存储缓冲寄存器（MBR）/ 存储数据寄存器（MDR）
- 程序计数器（PC）
- 指令寄存器（IR）

### 数据流

#### 取指周期

- 第一步：从PC把地址经MAR传到地址总线
- 第二步：存储器从控制线上得知地址已经准备好了，从地址总线读取地址，开始准备数据
- 第三步：存储器把数据送到数据总线，然后经其传送到MBR，再传送到IR
- 第四步：控制器让PC + 1（指令取完之后即+1，而不是处理完之后才+1，但是**跳转**指令必须要在指令执行完之后才能知道下一条指令的地址z）

![image-20211212214638775](计算机组织与结构.assets/image-20211212214638775.png)

#### 间址周期

- 第三步是从MBR送到MAR，即数据是地址，然后再次由地址总线送到存储器，得到数据
- 之后都是一样的

***由于执行周期比较复杂，本课程不作讲解***

#### 中断周期

- **写操作**，所有数据流指向存储器
  - 控制器 -> PC -> MBR -> 数据线 -> 存储器
    - 对PC内容的保存
  - 控制器 -> MAR -> 地址总线
    - 把某一个地址传入地址总线（PC），比如某个栈的指针

### 指令流水线

#### 定义

- 流水处理
  - 如果一个产品要经过几个制作步骤，通过把制作过程安排在一条装配线上，多个产品能在各个阶段同时被加工
  - 每个部门只处理其中一个步骤，而不是让一个部门把工作全部完成

- **指令流水线**：一条指令的处理过程分成若干个阶段，每个阶段由相应的功能部件完成

#### 两阶段方法

- 将指令处理分成两个阶段
  - 取指令和执行指令
- 在当前指令的执行期间取下一条指令
- 问题：执行时间一般要长于取指时间
- 更多问题：
  - 主存访问冲突
  - 条件分支指令是的带去的下一条指令是未知的

![image-20211212214720443](计算机组织与结构.assets/image-20211212214720443.png)

#### 六阶段方法

- 为了进一步加速，流水线必须有更多阶段
  - 取指令（FI）：读下一条预期的指令到缓冲器
  - 译码指令（DI）：确定操作码和操作数指定符
  - 计算操作数（CO）：计算每个源操作数的有效地址
  - 取操作数（FO）：从存储器
  - 执行指令（EI）
  - 写操作数（WO）
- 各个阶段所需要的时间几乎是相等的

![image-20211212214852444](计算机组织与结构.assets/image-20211212214852444.png)

- 问题
  - 不是所有指令都包含6阶段
    - 例：一条LOAD指令不需要WO阶段
    - 为了简化流水线硬件设计，在假定每条指令都要求这6个阶段的基础上来建立时序
  - 不是所有的阶段都能并行完成
    - 例：FI、FO和WO都涉及存储器的访问
  - 若这6个阶段不全是相等的时间，则会在各个流水阶段**涉及某种等待**
  - **条件转移指令和中断**能使若干指令的读取变为无效
  - ![image-20211212214901860](计算机组织与结构.assets/image-20211212214901860.png)

#### 流水线性能

- ![image-20211212214919167](计算机组织与结构.assets/image-20211212214919167.png)
- ![image-20211212214929868](计算机组织与结构.assets/image-20211212214929868.png)
  - 第一个k是指最后一个指令的执行时间，n-1指的是前面的n-1个指令阶梯性执行时间：每一个周期发送一个新指令


##### 加速比

![image-20211213205634125](计算机组织与结构.assets/image-20211213205634125.png)

  - 没有使用流水线的时间 / 使用流水线的时间
    - 一定大于1

![image-20211212214939917](计算机组织与结构.assets/image-20211212214939917.png)

- 误解：流水线中的阶段数越多，执行速度越快
- 原因
  - 在流水线的每个阶段，将数据哦册那一个缓冲区移动到另一个缓冲区以及执行各种准备和传递功能都涉及一些开销
  - 处理内存和寄存器依赖以及优化管道使用所需的控制逻辑随着阶段的增加而急剧增加

##### 吞吐率

- 单位时间内流水线所完成指令或输出结果的数量

- **时间单位换算：**
  - 1秒(s)=1000毫秒(ms)(3次方)
    =1000000微秒微秒(μs)(6次方)
    =1000000000纳秒(ns)(9次方)

###### 最大吞吐率

- 指流水线在达到稳定状态后所得到的吞吐率

![image-20211213210942284](计算机组织与结构.assets/image-20211213210942284.png)

###### 实际吞吐率

- 指m段流水线完成n个任务所达到的吞吐率

![image-20211213211012529](计算机组织与结构.assets/image-20211213211012529.png)

#### 冒险

##### 定义

- 在某些情况下，指令流水线会阻塞或停顿（stall），导致后续指令无法正确执行

##### 类型

###### 结构冒险

- 原因：已进入流水线的不同指令在同一时刻访问相同的硬件资源
- 解决：使用多个不同的硬件资源，或者分时使用同一个硬件资源
- 下图👇左边是分时，右边是使用多个不同的硬件

![image-20211216140409024](计算机组织与结构.assets/image-20211216140409024.png)

###### 数据冒险

- 原因：未生成指令所需要的数据

![image-20211216140507741](计算机组织与结构.assets/image-20211216140507741.png)

- 第一步是r1是输出结果，后面的r1是输入。要求r1在add完之后再进行后续操作

- **解决方案1：**插入nop指令（nop指令啥也不干）
- ![image-20211216140633678](计算机组织与结构.assets/image-20211216140633678.png)

- **解决方案2：**插入bubble（硬件层面的解决方案：让硬件上阻塞）
- ![image-20211216140658201](计算机组织与结构.assets/image-20211216140658201.png)
- **解决方案3：**转发（forwarding）/ 旁路（bypassing）
- ![image-20211216140848741](计算机组织与结构.assets/image-20211216140848741.png)

- 原本是在add指令结束之后才拿到r1，现在是在add的**ALU运算完**之后即拿出结果，送入其他指令的**ALU前**
- **解决方案4：**交换指令顺序（主要解决load word指令的问题）
- ![image-20211216141030926](计算机组织与结构.assets/image-20211216141030926.png)

- 调整顺序之后减少了2次等待

###### 控制冒险

- 原因：指令的执行顺序被更改
  - 转移：分支，循环
  - 中断
  - 异常
  - 调用/返回

- 解决：取多条指令
  - 多个指令流：赋值流水线的开始部分，并允许流水线同时取这两条指令，使用两个指令流
  - 预取分支目标：识别出一个条件分支指令时，除了取此分支指令之后的指令外，分支目标处的指令也被取来
  - 循环缓冲器：由流水线指令取指阶段围湖的一个小的但极高速的存储器，含有n条最近顺序取来的指令
- 解决：分支预测
  - 静态预测
    - 预测绝不发生
    - 预测总是发生
    - 依操作码预测
  - 动态预测
    - 发生/不发生切换
      - ![image-20211216141634666](计算机组织与结构.assets/image-20211216141634666.png)
    - 转移历史表
      - ![image-20211216141835818](计算机组织与结构.assets/image-20211216141835818.png)

## chapter16、控制器

### 寄存器分类

- 用户可见寄存器（user-visible register）
  - 允许变成人员通过机器语言或汇编语言访问，通过优化寄存器的使用而减少对主存的访问
- 控制和状态寄存器（control and status register）
  - 由控制器来控制CPU的操作，并由拥有特权的操作系统程序来控制程序的执行
  - 大多数控制和状态寄存器在大多数机器上是用户不可见的
    - 某些在控制或操作系统模式下执行的机器指令是用户可见的
  - 两者的区分并不严格

#### 用户可见寄存器

- 通用寄存器（general-purpose register）
  - 可被程序员指派各种用途
- 数据寄存器（data register）
  - 进可用于保持数据而不能用于操作数地址的计算
- 地址寄存器（address register）
  - 可以说自身有某些通用性，或是专用于某种具体的寻址方式
  - 例如：段指针、变址寄存器、栈指针...
- 条件码寄存器（condition codes register）/ 标志（flag）寄存器
  - CPU硬件设置这些条件位作为操作的结果
  - 至少是部分用户可见的

##### 设计出发点

- 使用完全通用的寄存器还是规定各寄存器的用途
- 寄存器数量
  - 太少的寄存器会导致更多的存储器访问
  - 太多的寄存器又不能显著地减少存储器访问
- 寄存器长度
  - 应能保存大多数数据类型的值
  - 某些机器允许两个相邻的寄存器作为一个寄存器来保持两倍长度的值

##### 保存和恢复

- 子程序调用会导致自动保存所有用户可见的寄存器，并在返回时自动取回
  - 这些保存和回复是作为调用和返回指令执行功能的一部分，由CPU完成
  - 这允许各个子程序独立地使用用户可见寄存器
-  子程序调用之外保存用户可见寄存器的相关内容是程序员的责任， 需要在程序中为此编写专门的指令

#### 控制和状态寄存器

##### 类别

- 程序计数器（PC）
  - 存有待取指令的地址

- 指令寄存器（IR）
  - 存有最近取来的指令，在其中分析操作码和操作数

- 存储器地址寄存器（MAR）
  - 直接与地址总线相连，存有存储器位置的地址

- 存储器缓冲寄存器（MBR）
  - 直接与数据总线相连，存有将被写入存储器的数据字或从存储器读出的字，用户可见寄存器再与MVR交换数据
  - ALU可对MBR和用户可见寄存器直接存取

- 程序状态字（Program status word，PSW）

  - 一个或一组包含状态信息的寄存器，包含条件吗加上其他状态的信息

  - 包含的字段或标志
    - 符号（Sign）：
    - 零（Zero）
    - 进位（Carry）
    - 等于（Equal）
    - 溢出（Overflow）
    - 中断允许/禁止
    - 监管（Supervisor）：指出CPU是执行在监管模式中还是在用 户模式中



##### 设计出发点

- 对操作系统的支持
  - 某些类型的控制信息是专门为操作系统使用的
  - 若CPU设计者对将要使用的操作系统有基本的了解，则寄存器的组织可能在一定程度上为该操作系统定制
- 控制信息在寄存器和存储器之间的分配
  - 一种普遍的做法是将存储器最前面（最低地址）的几百或几千个字用于控制目的
  - 在成本和速度之间进行权衡



### 微操作

- 执行程序时，计算机操作是由一些列指令周期组成，每个周期执行一条机器指令
- 每个指令周期又可以看作是有几个更小的子周期组成
  - 包括：取指、间址、执行、中断
- 每个子周期由一系列涉及**CPU寄存器操作**的更小步骤组成，这些步骤称为**微操作**

![image-20211221000101278](计算机组织与结构.assets/image-20211221000101278.png)

#### 取指周期

- 出现在每个指令周期的开始，将指令从存储器中取出
- 具体示例：ppt图
- 假设操作也有时钟，每一个操作的时长是等长的。每一个t是一个时间单位

![image-20211221000334673](计算机组织与结构.assets/image-20211221000334673.png)

#### 间址周期

- 如果指令采用间接寻址，则再指令执行前有一个间址周期

![image-20211221000608320](计算机组织与结构.assets/image-20211221000608320.png)

- 完成间址周期后，IR的状态和不适用间接寻址的状态是相同的，可以进入下一个周期？？？

#### 执行周期

- 对于不同的操作码，会出现不同的微操作序列

![image-20211221000615365](计算机组织与结构.assets/image-20211221000615365.png)

#### 中断周期

- 在完成执行周期时，要确定是否有允许的中断产生
- 如果有，则出现一个中断周期

![image-20211221000623217](计算机组织与结构.assets/image-20211221000623217.png)

#### 微操作分组原则

- 时间的流动顺序必须是恰当的
  - 例：MAR <- (PC)必须先于MBR <- 内存，因为内存读操作要使用MAR中的地址
  - 先把通过MBR把PC存到MAR，再通过内存进行读操作

- 必须避免冲突
  - 例：MBR <- 内存和IR <- MBR 这两个微操作不应出现在同一时间单位里
    - 不能对同一个寄存器同时读写
- 满足上述条件下， 所用的时间单位尽可能少（尽可能异步）

#### 指令周期代码

- 取指、间址、终端周期各有一个微操作序列，执行周期则对于每个操作码有一个微操作序列
  - 取值、间址、执行、中断各有一个微操作序列
  - ICC寄存器有两位数，用来判断当前时在哪个子周期，以及实现子周期的切换以及指令的连续读取

![image-20211221000707191](计算机组织与结构.assets/image-20211221000707191.png)

#### CPU内部总线

- ALU和寄存器都连接到CPU内部总线上
- 为了数据在该内部总线和各寄存器之间传递，内部总线和寄存器之间有门和控制信号
- 控制线控制着数据和系统总线（外部）的交换以及ALU的操作

![image-20211221000751086](计算机组织与结构.assets/image-20211221000751086.png)

- 注：*累加寄存器*（AC）通常简称为累加器，它是一个通用寄存器。

![image-20211221000805993](计算机组织与结构.assets/image-20211221000805993.png)

### 控制CPU的功能需求

- CPU的基本元素
  - ALU，寄存器组，内部数据通路，控制器，外部数据通路
- CPU需要完成的微操作
  - 在寄存器之间传送数据
  - 将数据由寄存器传送到外部接口（如系统总线）
  - 将数据由外部接口传送到寄存器
  - 将寄存器作为输入和输出，完成算术和逻辑运算
- 控制器的两个基本任务
  - 定序（sequencing）：根据正被执行的程序，控制器使CPU以整齐的顺序通过一系列微操作
  - 执行（execution）：控制器使每个微操作得以完成

### 控制器的输入

- 指令寄存器：当前指令的寻址方式和操作码（此两数据影响控制器的行为）
- 标志：确定CPU的状态和前一个ALU操作的结果
- 时钟：控制器要在每个时钟脉冲完成一个或一组同时的微操作
- 来自控制总线的控制信号：向控制器提供控制信号
  - 例：中断请求

![image-20211221000817238](计算机组织与结构.assets/image-20211221000817238.png)

### 控制器的输出

- CPU内的控制信号
  - 用于寄存器之间传送数据
  - 用于启动特定的ALU功能
- 到控制总线的控制信号：
  - 到存储器的控制信号
  - 到I/O的控制信号

![image-20211221000901902](计算机组织与结构.assets/image-20211221000901902.png)

#### 示例：取指周期

![image-20211221000850920](计算机组织与结构.assets/image-20211221000850920.png)

**（总线在图的左边）**

### 控制器的最小特性

- 它只需要知道将被执行的指令和算术、逻辑运算结果的性质（如正负、溢出等），而不需要知道正被处理的数据或得到的实际结果具体是什么
- 它至少以少量的送到CPU内的和送到系统总线上的控制信号来实现控制

### 控制器实现

#### 硬布线实现
  -  控制器是一个组合电路，把输入逻辑信号转换为一组输出逻辑信号，即控制信号

  - 控制器输入
      - 标志和控制总线信号
        - 每位都有特定意义
      - 指令寄存器
        - 通过译码，使每一个操作码由一个唯一的逻辑输入
        - 译码器有n个输入和$2^n$个输出
            - 控制器要考虑变长的操作码，译码器会更复杂些
      
      ![image-20211221000946775](计算机组织与结构.assets/image-20211221000946775.png)
      
      - 时钟
        - 在一个指令周期内，控制器要在不同时间单位发送不同的控制信号
        - 使用一个定时器作为控制器的输入，并且控制器在指令周期结束时必须通知定时器以使其重新开始计数
      
      ![image-20211221000956794](计算机组织与结构.assets/image-20211221000956794.png)
      
  - 控制器逻辑
      - 为每个输出的控制信号设计一个关于控制器输入的布尔表达式
      - 定义两个新的控制信号P和Q
           - PQ = 00：取指周期，PQ = 01：间址周期，PQ = 10：执行周期，PQ = 11：中断周期
           - 示例：
      
      ![image-20211221001014716](计算机组织与结构.assets/image-20211221001014716.png)
      
  - 缺点：当输入逐渐增多时，实现布尔表达式的电路会越来越复杂
#### 微程序实现

##### 基本概念和思路

- 微程序（固件）介于硬件与软件之间
  - 设计固件比设计硬件容易，但写固件程序比软件程序难
  - 微指令序列
- 微指令：每行描述一个时间内出现的一组微操作
- 基本思路
  - 对于每个微操作，控制器的任务是产生**一组控制信号**，即控制器发出的每根控制线或开或关（每根控制线由一个二进制数字表示）
  - **构造一个控制字**，每位表示一根控制线，这样每个微操作能用控制字中的不同的0和1的样式来表示
  - 将这些**控制字串在一起**，可以表示控制器需要完成的微操作序列

- 由于微操作序列不是固定的，把控制字放入一个存储器单元中，每个字都有自己唯一的地址
  - 添加少数几位用于指示条件的真假
    - 若条件位指示的条件为假，则顺序执行下一条指令
    - 若条件位指示的条件为真，则地址字段指向的微指令是将被执行的下一条微指令
  - 给每个控制字添加一个地址字段，以指示某种条件为真时，将要执行的下一控制字的位置

![image-20211221161840099](计算机组织与结构.assets/image-20211221161840099.png)

##### 微程序执行

![image-20211221162119991](计算机组织与结构.assets/image-20211221162119991.png)

#### 微程序控制器

##### 任务

- 微指令定序
  - 根据当前的微指令、条件标志和指令寄存器的内容，产生下一微指令的控制存储器地址
  - 设计考虑
    - 微指令的大小：减小微指令的大小就能节省控制存储器的成本
    - 地址生成时间：尽可能快地执行微指令
- 微指令执行
  - 产生控制信号：发往CPU内部，送往外部控制总线或其他外部接口

##### 定序（了解即可）

![image-20211221162436095](计算机组织与结构.assets/image-20211221162436095.png)

##### 构成

- 定序逻辑：向控制地址寄存器装入地址，并发出读命令
- 控制地址寄存器：含有下面即将被读取的微指令地址
- 控制存储器：存有一组微指令
- 控制缓冲寄存器：存放被读出的微指令

##### 工作流程

-  为执行一条指令，定序逻辑发出一个 读命令给控制存储器
- 当一条微指令由控制存储器读出后， 即被传送到控制缓冲寄存器
- 控制缓冲寄存器的内容生成控制信号， 并为定序逻辑提供下一条地址信息
  - 控制缓冲寄存器的左半部分与控制 器发出的控制线相连
  - 由控制存储器读一条微指令等同于 执行这条微指令
- 定序逻辑根据这个地址信息和ALU标志，将新的地址装入到控制地址寄存 器中

![image-20211221162739681](计算机组织与结构.assets/image-20211221162739681.png)

- 生成新地址的三个选择
  - 取顺序下一条微指令：加1到 控制地址寄存器
  - 基于跳转微指令转移到一个新的例程：将控制缓冲寄存器的地址字段装入控制地址寄存器
  - 转移到一个机器指令例程：根据IR中的操作码向控制地址寄存器装入机器指令例程的第一条微指令

![image-20211221162942171](计算机组织与结构.assets/image-20211221162942171.png)

- 优点 
  - 简化了控制器的设计任务
  - 实现起来既成本较低，也能减少出错机会
- 缺点
  - 要比采用相同或相近半导体工艺的硬布线控制器慢一些

## chapter17、输入输出

### 外围设备

- 输入/输出操作通过连接到输入输出模块的各种外部设备完成，这些外部设备提供了在外部环境和计算机系统之间的数据交换，通常成为**外部设备**，简称为**外设**
- 类型
  - 人可读设备：适用于与计算机用户通信
    - 显示器、打印机...
  - 机器可读设备：适用于与设备通信
    - 磁盘，磁带...
  - 通信设备：适用于与远程设备通信

- 外设不能直接连接到系统总线上
  - 外设种类繁多，操作方法多种多样
    - 而计算机系统基本上只有“读”和“写”两种操作
  - 外设的数据传送速度一般比存储器或处理器的慢得多
  - 某些外设的数据传送速度比存储器或处理器要快
  -  外设使用的数据格式和字长度通常与处理器不同

### I/O模块

- 通过系统总线或中央交换器和存储器连接
- 通过专用数据线与一个或多个外设连接’

**I/O模块是计算机内部系统和外设之间的桥梁！属于计算机系统！但是外设不属于计算机系统！**

### 外围设备的接口

- *和外围设备的交互以一个相对统一的方式进行！*

- 输入/输出模块的接口以**控制**、**状态**和**数据信号**的形式出现
- 与设备相关的**控制逻辑**控制外设的操作，以响应来自输入/输出模块的命令
- **缓冲器**用于缓存输入/输出模块和外设之间的数据
  - 解决I/O模块和外设传输数据时，外设数据传输速率和计算机传输数据速率不一的问题
  - 缓冲器的大小一般为8位或16位

### I/O模块的功能

- 处理器通信
  - 命令译码：输入/输出魔魁啊接受来自处理器的命令，这些命令一般作为信号发送到控制纵贯线
  - 数据
  - 状态报告
  - 地址识别
- 设备通信
  - 通信内容包含命令、状态信息和数据
- 数据缓冲
  - 外设的数据传送速度一般比存储器或处理器的慢得多
  - 某些外设的数据传送速度比存储器或处理器要快
- 控制和定时
  - 处理器会非预期的与一个或几个外设进行去通信
  - 一些内部资源，如主存和系统总线，是被共享的
  - 例如：控制从外设到处理器的数据传送包含以下几个步骤
    - ？
    - ？
    - ？
    - ？
- 检错
  - 检错并把差错信息报告给处理器
  - 差错类型
    - 设备报告的机械和电路故障
    - ？

### I/O模块的结构

### 外部接口

- 接口类型
  - 并行接口：多跟线连接输入/输出模块和外设，同时传送多位数据
  - 串行接口：只有一根线用于传输数据，每次只传输一位数据
- 目前多用串行接口
  - Why？
    - 并行接口需要保证所有数据同步传送
      - 传送路程缩短（线不能太长）
      - 传送间隔加大（传输频率不能太高，导致限制传输速率）
    - 由于并行接口要求每次同时传送，当传输速度和总线长度增加时，总线的时钟频率会受到限制
- 例：USB 通用串行总线

### I/O操作计数

- 编程式I/O：处理器通过执行程序来直接控制I/O操作，当处理器发送一条命令到I/O模块式，它必须等待，直到I/O操作完成
- 中断驱动式I/O：处理器发送一条I/O命令后，继续执行其他指令，并且当I/O模块完成其工作后，菜区中断处理器工作
- 直接存储器读取（Direct Memory Access，DMA）：I/O与主存直接交换数据，而不需要处理器的干涉

#### 编程式I/O

- 当处理器在执行过程中遇到一条与I/O操作有关的指令时，它通过发送指令到适当的I/O模块来执行这条指令
- I/O模块将执行所要求的东作, 然后在I/O状态寄存器中设置一些适当的位
- I/O不会中断处理器, 因此处理器需要周期性地检查I/O模块的状态, ???
- CPU在处理I/O时, 无法异步处理其他事务, 100%处理I/O事务

##### I/O命令

- 为了执行I/O操作, 处理器发送一个指定具体I/O模块和外设的地址, 并发送一条**I/O命令**
- 类型
  - 控制命令
  - 测试命令
  - 读命令
  - 写命令

##### I/O指令

- I/O指令很容易映射为I/O命令, 并且两者之间是简单的一一对应关系
  - 指令的形式取决于外设寻址方式
- 编制方式
  - 存储器映射式I/O:存储单元和I/O设备有统一的地址空间
    - 能使用大的指令系统, 可进行更有效的编程
    - 但是I/O设备占用地址空间
  - 分离式I/O
    - 让总线计有存储器的读写线, 也有输入和输出的命令线

#### 中断驱动式I/O

- 处理器发送一个I/O命令到模块, 然后去处理其他有用的工作
- 当I/O模块准备和处理器交换数据时, 它中断处理器以请求服务
- 处理器执行数据传送, 最后恢复它原先处理的工作



- 从I/O模块的角度看
  - I/O模块接受到来自处理器的读命令
  - I/O模块从相关的外设中读入数据
  - 一旦数据进入I/O模块的数寄存器后, 该模块通过控制总线给处理器发送中断信号
  - I/O等待直到处理器请求该数据时为止(等到处理器响应为止)
  - 当处理器有数据请求时, I/O??
- 从处理器的角度来看
  - 处理器发送一个读命令
  - 处理器离开去做其他的事情, 并在每个指令周期结束时检查中断
  - 当来自I/O模块的中断出现时, 处理器保存当前程序的现场
  - ??
  - ??
  - ??

##### 中断允许和中断禁止



- 中断处理过程中是**中断允许**, 说明可以嵌套中断

###### 响应优先级和处理优先级

- 优先响应 响应优先级最高的, 优先处理 处理优先级最高的;
- 高处理优先级的中断对同级和低处理优先级的中断视而不见

**掩码字**: 表示中断之间: 谁(行)可以屏蔽谁(列)



##### 设备识别

- 多条中断线
  - 即使有多条中断线可用, 每条线上也需要采用其他三种技术中的一种
- 软件轮询
  - 轮询每一个I/O模块来确定是哪个模块发生的中断
- 菊花链
  - 所有的I/O模块共享一条中断请求先, 中断应答先采用菊花链穿过这些中断模块
- 独立请求
  - 特定的中断控制器??

##### 分配优先级

- 多条中断线
- 软件轮询
- 菊花链: 链接模块次序
- 独立请求:中断控制器决定

#### 直接存储器存取

- 前面两种经过CPU的方式的不足
  - I/O传送速度授处理器测试和服务设备速度的限制
  - 处理器负责管理I/O传送, 对于每一次I/O传送, 处理器必须执行很多指令
- 直接存储器存取
  - 无需经过处理器即可直接访问内存的模块

- 把CPU处理中断的模块剥离出来, 单独作为一个硬件结构: DMA

##### DMA结构

- 处理器通过发送以下信息向DMA模块发出命令:
- 处理器继续进行其他工作: 读/写, I/O设备地址, 内存中的起始为止, 字数
- DMA模块将全部数据块, 每次一个字, 直接将数据传输到存储器或从存储器读出, 而无需经过处理器
- 当传输完成时, DMA模块向处理器发送一个中断信号

- DMA大多数连接的是高速I/O设备, 因此*当DMA和CPU争夺主存的访问*时, 应该**优先DMA**, 防止高速I/O设备中的数据被冲刷掉

##### DMA内存访问

###### CPU停止法

- 优点: 控制简单
- 缺点: 影响CPU, 没有充分利用内存
- 适用: 高速I/O设备的块传输
  - 但是高速I/O设备的数据可能是一波一波的过来, 在间歇的过程中, DMA占用主存, CPU的资源浪费

###### 周期窃取

- DMA只要不用了, 就立刻把主存访问权限让出来

- 优点: 充分利用CPU和内存, 及时响应I/O请求
- 缺点: DMA每次都请求总线
- 适用: I/O周期大于存储周期

###### 交替分时访问

整个存储器周期一分为二, 上半周期响应CPU, 下半周期响应DMA

- 优点: CPU未停止或等待, DMA不请求总线
- 缺点: CPU周期大于存储周期