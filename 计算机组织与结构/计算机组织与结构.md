# 计算机组织与结构

## chapter1、intro

### 什么是计算机？

-**通用电子数字计算机**

-通用：不是一种专用设备，所有计算机在给予足够时间和容量存储器的条件下，都可以完成同样的计算。党希望完成新的计算时，不需要对计算机重新设计

### 计算机系统

-硬件：处理器、存储器、外部设备

-软件：程序、文档

### 组织与结构

组织：对编程人员不可见

结构：对编程人员可见

### 计算机简史

#### 第一代：真空管

ENIAC：第一台通用计算机

EDVAC：采用冯.诺伊曼结构（普林斯顿结构）

​	冯诺依曼结构的三个基本原则：

​		-二进制

​		-存储程序执行

​		-五个组成部分

​			-主存储器：地址和存储的内容（important） 

​			-算数逻辑/处理单元：执行信息的实际处理

​			-程序控制单元：指挥信息的处理

​			-输入设备

​			-输出设备

#### 第二代：晶体管

体积更小、更便宜、发热更少，而且能以与电子管相同的方式建造计算机

使用更复杂的算数逻辑单元和控制器，使用高级编程语言

#### 第三代及后续几代：集成电路

#### 摩尔定律

​	-每18个月晶体管的数量增加1倍

### 计算机发展：变与不变

-![image-20210902151144693](计算机组织与结构.assets/image-20210902151144693.png)

### 计算机性能

> #### CPU性能

-系统时钟

​	-时钟频率/时钟速度（单位：Hz）：计算机执行最基本操作的基本速率（以每秒周期数为单位）

​	-时钟周期/时钟滴答声：CPU的单个电子脉冲

​	-周期时间（单位：s）：两个脉冲之间的时间

​		-有时被称为**时钟周期**

![image-20210902153708538](计算机组织与结构.assets/image-20210902153708538.png)

> **但是有时，cpu会专门做一块硬件来处理某条特定的指令，使得这个特定的指令执行的特别快，显得cpu性能很好。为了防止这种以偏概全的作弊方法，并找到一种公平的方法来量化cpu性能我们引入**：

**![image-20210902154500534](计算机组织与结构.assets/image-20210902154500534.png)**

所以，有些常见的跑分软件的原理即：拿一堆基准程序来跑

![image-20210902154801831](计算机组织与结构.assets/image-20210902154801831.png)

$$MIPS = \frac{f}{CPI * 10^6}$$

## chapter2、计算机的顶层视图

### 计算机组件

​	-数据和指令存储在单个读写存储器

​	-该存储器的内容可按位置寻址，而无需考虑其中包含的数据类型

​	-从一条指令到下一条指令以顺序方式执行（除非明确修改）

### CPU

​	PC：程序计数器

​	IR：指令寄存器

​	MAR：存储器地址寄存器

​	MBR：存储器缓冲寄存器

​	I/O AR：I/O地址寄存器

​	I/O BR：I/O缓冲寄存器

​	执行单元

​	-问题：CPU在等待I/O设备时保持空闲

​	-解决方法：

​		-中断：其他模块（例如I/O)可以中断正常处理顺序的机制

![image-20210909144019956](计算机组织与结构.assets/image-20210909144019956.png)

​			-在等I/O 的时候中断以下去处理其他的程序，待I/O准备好以后，其打断CPU，让其继续未完成的			操作。

​			-中断程序全部处理完了之后，再回到用户程序，即：中断程序优先级更高

​			![image-20210909144252335](计算机组织与结构.assets/image-20210909144252335.png)

### 存储器

​	问题：

​		-主存和CPU之间传输数据的速度跟不上CPU的速度

​		![image-20210909151913203](计算机组织与结构.assets/image-20210909151913203.png)

​	解决：

​		-添加一级或多级缓存（cache）以减少存储器访问频率并提高数据传输速率（层次式存储结构）

​		-增大总线的数据宽度，来增加每次所能取出的位数

​		-...

​	约束：

​		-容量：越大越好

​		-速度：跟上存储器

​		-成本：相对于其他组件合理	

​		-约束之间的关系：更短的访问时间，更高的每比特成本



### I/O模块

​	-与CPU和内存交换从外部来源收集的数据

​	问题：I/O性能跟不上CPU速度的提升

​	解决：

​		-缓冲

​		-新的接口技术

​		-...

### 系统总线

​	-是连接两个或多个设备的通信通路

![image-20210909155044050](计算机组织与结构.assets/image-20210909155044050.png)

![image-20210914162101263](计算机组织与结构.assets/image-20210914162101263.png)

## chapter3、数据的机器级表示

### 编码：

​	定义：用少量简单的基本符号对复杂多样的信息进行一定规律的组合。

​	注意：不可能用离散有限的数据准确的表示连续无限的现实变量。

![image-20210914164710690](计算机组织与结构.assets/image-20210914164710690.png)

#### 	采用二进制的原因：

​		-多种物理器件可以表示两种稳定的状态，用于表示0和1

​		-二进制的编码和运算规则简单

​		-1和0可以对应逻辑命题中的“真”与“假”

### 数值型数据的二进制数表示：

#### 		整数类型

##### 					无符号整数

##### 					有符号整数：原码，反码，移码，补码

- 定点整数：小数点固定在最后一位之后
- 定点小数：纯小数，约定小数点位置在符号位之后、有效数值部分最高位之前

​						-补码的表示：略

​						-补码的解析：$[X]_C = X_nX_{n-1}...X_1 \to X = -X_n * 2^{n-1} + X_{n-1} * 2^{n-2}+...+ X_1 * 2^0$

#### 二进制编码的十进制数表示

> ***即NBCD码***

##### 好处和特点：

- 可以同时保证精度和表示范围
- 但是牺牲了位数（存储空间）

​				![image-20210914180046150](计算机组织与结构.assets/image-20210914180046150.png)

#### 	浮点数的二进制数表示

![image-20210916151523973](计算机组织与结构.assets/image-20210916151523973.png)



​			-基即为2，约定俗称为2.

​			-规格化数的表示范围：

- 规格化数阶码的表示范围是$2^{-126} \sim 2^{127}$
- 阶码全0表示下溢区的数，而阶码全1表示上溢区 & $NaN$

![image-20210916153154301](计算机组织与结构.assets/image-20210916153154301.png)



此时计数：小数精度更高是因为，小数的相对偏差更大，精度要求更高。而大数精度要求较小，所以大数的精度可以稍微低一点

IEEE 754规定的舍入标准是**向偶数舍入**？

![image-20210922215703677](计算机组织与结构.assets/image-20210922215703677.png)

### float、double

- float只有23 + 1 = 24位有效位数，$10^7 \lt 2^{24} - 1 \lt 10^8$，所以理论上float的十进制有效位数是7位
  - 且它所能表示的数是离散分布在数轴上的
  - 每个区间$2^i \sim 2^{i+1}$中可以表示$2^{23}$个数
- double有52 + 1 = 53位有效位数，$10^{16} \lt 2^{53} - 1 \lt 10^{17}$所以理论上double的十进制有效位数是16位

## chapter4、数据校验码

### 差错

​	-分类

![image-20210924091940968](计算机组织与结构.assets/image-20210924091940968.png)

### 纠错

#### 	基本思想：

​		存储额外的信息以进行检错和校正

#### 	处理过程：

​		数据输入：

​				-使用函数$f$在M位数据$D$上生成K位校验码$C$

​		数据输出：

​				-使用函数$f$在M位数据$D^{'}$上生成K位校验码$C^{''}$，并与取出的K位码$C^{'}$（因为此时$C$在				拿出来的时候也可能出错，产生$C^{’}$）进行比较

​		-没有检测到差错：使用数据$D^{'}$

​		-检测到差错且可以校正：校正数据$D^{'}$来生成数据$D^{''}$并用数据$D^{''}$

​		-检测到差错但无法纠正：报告

![image-20210924093118459](计算机组织与结构.assets/image-20210924093118459.png)

​		注意：数据在经过存储器/网络时会发生错误，经过存储器/网络后的数据会发生改变！

### 奇偶校验码

#### 	基本思想：

​		增加1位校验码来表示数据中的1的数量是奇数还是偶数

#### 	处理过程

​		假设处理数据$D=D_M...D_2D_1$

​		-使用抑或操作

​			-特点：0跟任何数异或后还是那个数，因此0对异或运算没有影响

​							 1和1异或生成1

​			-因此奇数个1异或后生成1，偶数个1异或后生成0

​		-奇校验：奇数个1生成0，偶数个1生成1（和原数据放在一起，1的个数是奇数个）

​		-偶校验：奇数个1生成1，偶数个1生成0（和原数据放在一起，1的个数是偶数个）			 ![image-20210924093745197](计算机组织与结构.assets/image-20210924093745197.png)

#### 		校验分析

### ![image-20210924094455298](计算机组织与结构.assets/image-20210924094455298.png)			

总的来说，如果01位数出错了，但总体的奇偶性没变，则无法检测出来

也无法检测出来具体是哪一位出现了错误

而且发现了错误后无法纠正。

我们默认：较短长度（如1字节）的数据每次出错只会1位出错，因此奇偶校验码适用于较短长度（如1字节）的数据进行检错。

### 海明码

#### 		基本思想

​		-将数据分为几组，对每一组都使用奇偶校验码进行检错（可以是有重复的分组）

#### 		处理过程

​		-将M位数据分成K组

​		-数据输入

​			为数据$D$中每组生成1位校验码，合并得到K位校验码$C$

​		-数据输出

​			为数据$D^{'}$中每组生成1位校验码，合并得到新的K位校验码$C^{''}$

​		-检错：

​			将**校验码$C^{''}$和取出的校验码$C^{'}（读出来的12位里的4位校验码）$**按位进行**异或**，生成K位故障字（syndrome word）

​	![image-20210924103342918](计算机组织与结构.assets/image-20210924103342918.png)

数据位出错和校验码出错分别有M和K种情形

且我们假设数据出错和校验码出错不会同时发生。

通过设定M，我们可以求出需要K的最小值



#### 故障字的作用：

​	每种取值都反映一种情形（数据出错/校验码出错/未出错）

​	规则：

​		全都是0：没有检测到错误

​		有且仅有1位是1：错误发生在校验码的某一位，不需要校正（我们假设数据和校验码一起最多只有1位出错）

​		有多位为1：错误发生在数据中的某一位，将$D^{'}$对应数据位取反即可纠正。（得到	$D^{''}$（某一个数据参与且仅参与了多个组）



#### 校验分析

![image-20210924104954814](计算机组织与结构.assets/image-20210924104954814.png)



若故障字哪几位数值为1，则对应校验码出错（校验码$C_n$在$2^n$位上），说明其内有某个数据位出错。找出公共的数据位，即为出错的位



我们先规定数据位/校验码与故障字的关系，然后由此可以推导出数据位的划分（如何分组）

- 比如：$D_8$出错对应的故障字是1100，第四位和第三位有1，所以$C_3$和$C_4$的异或里$D_8$参与了运算

#### 本章作业会考！！！

### 循环冗余校验

​	适用于以流格式存储和传输大量数据

​	用数学函数生成数据和校验码之间的关系

#### 	基本思想

​		假设数据有M位，**左移数据K位（右侧补0）**，并用K+1位生成多项式除它（模2运算）

​		采用K位余数作为校验码

​		**把校验码放在数据（不含补的0）后面**，一同传输和或传输

#### 	交错

​		如果M+K位内容可以被生成多项式除尽，则没有检测到错误

​		否则，发生错误

![image-20210924111337400](计算机组织与结构.assets/image-20210924111337400.png)

### 补充：模2除法

模除的意思是做除法取余数（除完不要结果只要余数）
模x除，说的是除以几取余数。例如模10除就是除10取余，例如100做模十，余数就是0。不过人类一般是用十进制的，计算机用二进制的，所以这里的模x又有用x进制的意思了，例如100模二，结果仍然是0（这里是二进制数字100也就是十进制的4）
计算机模二除用的是异或运算，因为按位异或的结果与除法结果相同。



模2除法的特点就是：每一位除的结果不影响其它位，即不向上一位借位

模2除法原则：1、**被除数的首位为1，商为1**

​								2、**被除数的首位为0，商为0**
​    
​								3、**模2除法在减的时候等同于按位异或**，要保证每次除完首位都为0，才能进行右移
​    
​								4、计算时每次右移一位，当被除数的位数小于除数，其为余数

​								5、如果右移后，被除数首位为零，就除以全零



## chapter5、整数运算

### 算术逻辑单元（ALU）

### 全加器（最基本的单元）

#### 	串行进位加法器

​	-作用：完成一位（1 bit）的加法

![image-20210928164355219](计算机组织与结构.assets/image-20210928164355219.png)

$C_i$表示的是三个与运算做完后完成或运算（注意，这里的三个与运算可以同时进行）

但是$S_i$的抑或的有先后顺序的，x和y先异或好准备就绪，等着$C_{i-1}$

求$C$的延迟：$1ty + 1ty = 2ty$

求$S_i$的延迟：$3ty + 3ty = 6ty$

而计算异或时是要考虑同步的



#### 一个计算延迟的栗子

![image-20210928170116651](计算机组织与结构.assets/image-20210928170116651.png)

but 在$S_1$和$S_2$时，仍然是$6ty$，不满足$2n+1$。

#### 	

#### 	全先行进位加法器

![image-20210928172701168](计算机组织与结构.assets/image-20210928172701168.png)

**注：$P_i$为进位传递，$G_i$为进位生成**

**注：$C$是先做与再做或**



![image-20210928173419246](计算机组织与结构.assets/image-20210928173419246.png)

步骤1：先求所有的P和G —— 1ty

步骤2：求C —— 2ty **（和步骤1 异步）**

步骤3：X和Y异或—— 3ty **（步骤1、2和步骤3是同步的）**

步骤4：把步骤3的结果和C做异或，求得S **（和步骤1、2、3是异步的）**



##### 改进：

![image-20210928175215216](计算机组织与结构.assets/image-20210928175215216.png)

最后还要得到一个$C_{32}$，所以最后再还有一个（2+3）= 5ty



### 两种判断溢出的方法

![image-20210930140815966](计算机组织与结构.assets/image-20210930140815966.png)

注：溢出只可能发生在$X_n$和$Y_n$同号的情况下



### 减法电路

![image-20210930141449096](计算机组织与结构.assets/image-20210930141449096.png)

注：Mux指的是多路选择器（multiplexer）

​		 此电路把加法和减法做了一个统一，通过Sub信号决定多路选择器选择Y还是Y的	  取反

- 对于无符号数运算，可以通过CF的值判断是否发生了借位（够不够减）
- 对于有符号运算，则不能通过CF的值判断是否发生了借位（比如-68 - 80 = -148）
  - 一般通过SF和OF
  - 或者通过ZF判断



### 乘法

![image-20210930141658769](计算机组织与结构.assets/image-20210930141658769.png)

手工演算二进制乘法其实很类似手工演算十进制乘法

如果$Y_i = 0$，只执行移位操作

#### 一个栗子

![image-20210930142310031](计算机组织与结构.assets/image-20210930142310031.png)

![image-20210930142654732](计算机组织与结构.assets/image-20210930142654732.png)

注：把部分积P和乘数Y存在一个寄存器里面，因为Y和P的位数此消彼长，始终满足长度之和位2n的关系，所以如此操作可以充分利用存储空间

***例子***

![image-20210930142807557](计算机组织与结构.assets/image-20210930142807557.png)

**问题**：乘法在补码中可能会失效👇

![image-20210930142858546](计算机组织与结构.assets/image-20210930142858546.png)

***解决方法***：**布斯乘法**

![image-20210930143122228](计算机组织与结构.assets/image-20210930143122228.png)

把补码表示的Y用真值表示公式展开

精妙之处在第三行，利用变形使得式子形式统一（$Y_0 = 0$）

![image-20210930143457365](计算机组织与结构.assets/image-20210930143457365.png)

注1：第二点的意思是：$Y_i-Y_{i+1}$有$0,-1,1$三种取值可能，所以可能会对部分积产生三种影响

注2：应该使用带符号整数的算术右移，即sign_ext(始终保证右移是除以2的操作)



### 除法

#### 	恢复余数除法：

![image-20210930144932843](计算机组织与结构.assets/image-20210930144932843.png)

![image-20210930145148810](计算机组织与结构.assets/image-20210930145148810.png)

![image-20210930145328979](计算机组织与结构.assets/image-20210930145328979.png)

![image-20210930145655925](计算机组织与结构.assets/image-20210930145655925.png)

先把除数右移，让其最高位和被除数的次高位对齐

然后不断的把除数右移，商左移（商左移时通过控制逻辑判断是补0还是补1）



##### 优化

​	观察到余数（被除数）和商也满足此消彼长的关系，故将它们放在一起存储

![image-20210930150256487](计算机组织与结构.assets/image-20210930150256487.png)

![image-20210930150359357](计算机组织与结构.assets/image-20210930150359357.png)



PS：-7 / -2 = -3 ... -1

***余数减去除数之后，符号不能改变！***

***总之是要让余数的绝对值不断变小且让其符号不改变***

![image-20210930150744612](计算机组织与结构.assets/image-20210930150744612.png)

![image-20210930151318172](计算机组织与结构.assets/image-20210930151318172.png)

标红的一点即为:把商取反+1.



##### 一个栗子

![image-20210930151438154](计算机组织与结构.assets/image-20210930151438154.png)



我们判断是否"够减"时不是直观肉眼观察的, 而是先计算(同号相减、异号相加)，然后看结果相对于余数符号是否改变。若改变了则恢复，商0；反之保留运算结果，商1。

##### 思考：

有时候余数的符号会不等于初始被除数的符号，此时判断够减是以原始被除数的符号为准还是以余数的符号为准？

​	-看书上的栗子好像是以初始被除数的符号为准



#### 不恢复余数除法

​	基本原理

![image-20210930153304893](计算机组织与结构.assets/image-20210930153304893.png)

![image-20210930153401422](计算机组织与结构.assets/image-20210930153401422.png)

即如果余数和除数符号相同，左移减。否则左移加

![image-20210930153523021](计算机组织与结构.assets/image-20210930153523021.png)

##### 一个栗子

![image-20210930153550444](计算机组织与结构.assets/image-20210930153550444.png)

不恢复余数除法是直接对齐的，且第一次运算得到的是溢出位，不是真正的商，到最后要左移一位把其去掉

##### 思考：

有时候不恢复余数除法会失效，什么时候？如何解决？

- 如果中间余数结果出现全0时，到底是判为够减还是不够减

- 正好整除的时候失效，因为不恢复余数除法使用于有余数除法，其结束运算标准是除的次数，而不是余数是否为0



## chapter6、浮点数运算

### 加法和减法

- 流程图
- 其中有大量的判断来辅助程序节省运算（如红圈中的significand = 0？return other number ： continue exponents loop）
- 对阶、尾数加减后，如果尾数为0，说明相加的两个数互为相反数。此时要把exponent置0，然后再把结果（+-0）return
- 如果阶码溢出，返回无穷时，要把尾数清0
- 如果在规划化中间结果的时候，发现阶码为全0了，此时即结果变成了非规格化数，此时尾数要右移一位，保证和阶码$2^{-126}$对应。
- 注意：IEEE 754所能表示的最小数为$2^{-149}$，因此当数比此数还小的时候，判作下溢为0

![image-20211009151704055](计算机组织与结构.assets/image-20211009151704055.png)



- 对阶（保证两个阶码是相同的）

  - 原则是把小阶变大，尾数右移（原因是右移的时候可能高位会溢出，造成较大的精度损失）

- 尾数加减

  - 即为定点原码小数的加减运算（注意：所得结果也是原码！）
  - $X - Y = X + [Y]_{补}$
    - 若结果产生了进位，表示减法得到的结果和X同号，所得结果即为所求。
    - 若结果没有产生进位，表示减法得到的结果和X异号，得到的是数值为的补码形式，将所得结果求补重新化为绝对值原码形式，并把符号位取反，即得所求。

  

- 尾数规格化

  - 考虑保护位

- 尾数的舍入处理

  - 保护位100采用舍入到偶数
  - 就近舍入
  - 朝正无穷舍入：正数+1，负数舍掉
  - 朝负无穷舍入：正数舍掉，负数-1
  - 朝0舍入：全部舍掉

- 溢出判断

#### 一个栗子

![image-20211009153440887](计算机组织与结构.assets/image-20211009153440887.png)





### 乘法

![image-20211009153249010](计算机组织与结构.assets/image-20211009153249010.png)

如果上溢直接报错，如果下溢的话要先判断是否是非规格化数，然后再判断是否是下溢到0



### 除法

![image-20211009154157680](计算机组织与结构.assets/image-20211009154157680.png)



## chapter7、十进制运算

### 加法

#### 运算方法

![image-20211012165247620](计算机组织与结构.assets/image-20211012165247620.png)

当被加数超过10时，无论是在10 - 16还是16 - 18之间，都应该+6（0110）进行补偿

补偿数推导原理

```
x - 10 = y + x -16

x + y - 16 = x - 10

-> y = 6
```

#### 补偿硬件实现

- 模拟一位十进制的加减（四位二进制数）
- S2和S1位下面连的线就是实现+6（0110）的操作
  - 当C4旁边的或门信号为1时，加0110
  - 实现原理
    - C4为1，表示加法的4位结果在16 - 18之间
    - C4为0，但是S3为1，S2和S1至少有一个为1（表现为两个与门）

![image-20211012170007609](计算机组织与结构.assets/image-20211012170007609.png)

### 减法

#### 运算方法

![image-20211012171925932](计算机组织与结构.assets/image-20211012171925932.png)

- 模仿二进制运算，求十进制补码
  - 先十进制“取反”
    - 第一种方法：先按位反转，再加1010(10)
      - 推导：$9 - x = 15 - x + y - 16 \to \ y = 10$
    - 第一种方法：先加0110(6)，再按位反转
      - 推导：$9 - x = 15 - (x + y) \to \ y = 6$

##### 栗子

- ![image-20211012173137153](计算机组织与结构.assets/image-20211012173137153.png)

先转十进制补码，然后加，然后按照加法处理的方法看是否需要加



## chapter8、内部存储

### 定义

![image-20211014141140766](计算机组织与结构.assets/image-20211014141140766.png)  

- 注：寻址能力的真正含义应该是计算机可识别的存储单元位数。

### 存储器层次结构

![image-20211014142443329](计算机组织与结构.assets/image-20211014142443329.png)

- 越上面表示它越靠近CPU

### 半导体主存储器

- 以半导体芯片作为主存储器是最主流的做法
- 位元（Memory cell）：半导体存储器的基本元件
  - 特性：
    - 呈现两种稳态（获半稳态），分别表示二进制的0和1
    - 至少能被写入数据一次，用来设知状态
    - 能够被读取来获得状态信息

![image-20211014143155447](计算机组织与结构.assets/image-20211014143155447.png)

- 类型

![image-20211014143310431](计算机组织与结构.assets/image-20211014143310431.png)



#### 随机存取存储器

（Random Access Memory）

- 可以简单快速地进行读/写操作
- 易失的（volatile）
- 动态（dynamic）RAM / 静态（static）RAM
- 动态RAM需要刷新

##### DRAM

![image-20211014144201398](计算机组织与结构.assets/image-20211014144201398.png)

##### SRAM

- 静态可以保证不漏电（状态稳定，不需要刷新）

- ![image-20211014144401969](计算机组织与结构.assets/image-20211014144401969.png)

DRAM和SRAM的对比

![image-20211014144925497](计算机组织与结构.assets/image-20211014144925497.png)

##### 更高级的DRAM架构

- 类型
  - 同步DRAM，Synchronous DRAM
  - 双速率SDRAM，Double-Data-Rate SDRAM，DDR SDRAM（DDR）

传统DRAM是异步的，它要等待地址、控制信号、执行功能的延时，等待延时后，才能被读出或写入数据

![image-20211014150828099](计算机组织与结构.assets/image-20211014150828099.png)

- 每个时钟周期发送两次信号
- DDR2、DDR3...等做出的改进主要是缩短每次时钟周期的时间

#### 只读存储器(ROM/PROM)

- 特性
  - 非易失的（nonvolatile），不要求供电维持数据
  - ROM可读（不可以被修改）
- 应用
  - 微程序设计，库子程序，系统程序，函数表，**用于做保存出厂设置的系统盘**
- 问题
  - 固化数据需要较大的固定成本
  - 无出错处理机会：如果有一位出错，则整批ROM芯片只能报废
- ROM在出厂的时候已经写好，后续不可写

#### PROM

Programmable ROM

- 非易失的
- 只能被写入一次
  - 写过程是用电信号执行
  - 需要特殊设备来完成写或“编程”过程
- 好处：可以自己完成写的过程，写完之后仍然不可改
- 与ROM的对比
  - PROM提供了灵活性和方便性
  - ROM在大批量生产领域仍具有吸引力

#### 主要进行读操作的存储器

Read-Mostly Memory

- 特性
  - 读操作比写操作频繁得多
  - 非易失的
- 类型
  - EPROM（尽管命名后缀是ROM，但不是只读的，应该是RMM）
  - EEPROM（同上）
  - Flash memory

##### EPROM

Erasable programmable read-only memory

光可擦除/可编程只读存储器

- 特性
  - 光擦除，电写入
    - 擦除：在写操作之前把封装芯片暴露在紫外线下
      - 所有的存储单元都变回相同的状态
      - 每次擦除需要约20分钟
    - 注：重新写不能直接覆盖已有内容，要先把已有内容清楚再写入
- 和PROM对比
  - EPROM更贵，但它具有可多次改写的优点

##### EEPROM

电可擦除/可编程只读存储器Electrically erasable programmable read-only memory

- 特性
  - 可以随时写入而不删除之前的内容
  - 只更新寻址到的一个或多个字节
  - 写操作每字节需要几百微妙
- 与EPROM对比：
  - EEPROM更贵，且密度低（集成度低），写速度慢，支持小容量芯片

#### 快闪存储器

Flash Memory

- 特性
  - 电可擦除
  - 擦除时间可达几秒，比EPROM快多了
  - 可以在块级擦除，但不能在字节级擦除
  - 达到与EPROM相同的高密度（与EEPROM相比）
- 与EPROM、EEPROM对比
  - 价格和功能介于EPROM和EEPROM之间



### 寻址单元

- 由若干相同地址的位元组成
- 寻址模式
  - Byte
  - Word

cell相当于一个床位，addressable unit相当于一个房间，一个房间共用一个地址

![image-20211021140254107](计算机组织与结构.assets/image-20211021140254107.png)



### 存储阵列

- 大量的寻址单元排在一起
- 某一个寻址单元的确定是由行、列两根寻址线确定

![image-20211014154919637](计算机组织与结构.assets/image-20211014154919637.png)

#### 如何寻址

- 通过地址译码器

#### 如何刷新

即刷新电容，防止电容漏电漏到影响状态的表示

- 集中式刷新
  - 停止读写操作，并刷新每一行
  - 刷新时无法操作内存
- 分散式刷新
  - 在每个存储周期中，当读写操作完成时进行刷新
  - 会增加每个存储周期的时间
- 异步刷新
  - 每一行各自以64ms间隔刷新
  - 效率高：常用

![image-20211021141358269](计算机组织与结构.assets/image-20211021141358269.png)

![image-20211026200557165](计算机组织与结构.assets/image-20211026200557165.png)

👆例题：生成的刷新信号的间隔时间指的是行之间的刷新时间间隔

- 芯片引脚
- 操作芯片、读写内存的接口

如果是刷主存的话，先看芯片是怎么扩展的，位扩展的同时刷，字扩展的异步刷

![image-20211026113333973](计算机组织与结构.assets/image-20211026113333973.png)

### 芯片拓展

- 位扩展：增加寻址单元的位数，即增加一次写入和读出的位数，从4根数据线变为8根
- 地址线决定的是多少行、多少列，即寻址单元的个数
- 字扩展：如果16K * 8bit是7 * 7根地址线，那么64K * 8bit是8 * 8根地址线

![image-20211026113514507](计算机组织与结构.assets/image-20211026113514507.png)

- 黑色芯片焊在绿色内存板上即为内存条
- 在主板上插内存条是字拓展，插槽上组合多个存储模块

#### 

主存地址是27位，片内地址24位，与24位主存地址相同；12位是行号，低12位是列号

而主存的低3位地址是用来选片的，即确定8个字节中的哪一个。

芯片内地址不连续，是交叉编址，可以保证同时读写所有芯片

## chapter9、高速缓存存储器（cache）

![image-20211026114603436](计算机组织与结构.assets/image-20211026114603436.png)

Cache是为了解决**内存墙**的问题：CPU的速度比内存的速度快，且两者差距不断扩大，导致CPU”巧妇难为无米之炊”

### 基本思路

- 解决内存墙带来的CPU和主存协作问题
  - 在使用主存（相对大而慢）之余，添加一块小而快的Cache
  - Cache位于CPU和主存之间，可以集成在CPU内部或作为主板上的一个模块
  - Cache中存放了主存中的部分信息的副本

![image-20211026114935402](计算机组织与结构.assets/image-20211026114935402.png)

### 工作流程

- 检查（Check）：当CPU试图访问主存中的某个字时，首先检查这个字是否在Cache中
- 检查后分两种情况处理
  - **命中（Hit）**：如果在Cache中，则把**这个字**传送给CPU
  - **未命中（Miss）**：如果不在Cache中，则将主存中包含这个字**固定大小的块（block）**读入Cache中，然后再从Cache传送该字给CPU

![image-20211026115806596](计算机组织与结构.assets/image-20211026115806596-16352206869931.png)

#### Hit判断

- 冯诺依曼体系的设计
  - CPU通过**位置**对主存中的内容进行寻址，不关心存储在其中的内容
  - Cache通过**标记（tags）**来标识其内容在主存中的对应**位置**
  - CPU就通过检查标记是否是要访问字节的地址来判断是否Hit

#### 程序访问的局部性原理

（CPU访问主存有规律，导致Cache命中率高）

- 定义
  - 处理器频繁访问主存中相同位置或者相邻存储位置的现象
- 类型
  - **时间局部性**：在相对较短的时间周期内，重复访问特定的信息（也就是访问相同位置的信息）
  - **空间局部性**：在相对较短的时间周期内，访问相邻存储位置的数据
    - **顺序局部性**：当数据被线性排列和访问时，出现的空间局部性的一种特殊情况
      - 例如：遍历一维数组中的元素

- 是相对较短时间周期内的一个统计规律

![image-20211026120949718](计算机组织与结构.assets/image-20211026120949718.png)

#### 向cache传送内容

- 利用“时间局限性”
  - 将未命中的数据在返回给CPU的同时存放在Cache中，以便再次访问时命中

![image-20211026121422693](计算机组织与结构.assets/image-20211026121422693.png)

#### 传送块而不是传送字

- 利用“空间局部性”
  - 将包含所访问的字的块存储到Cache中，以便在访问相邻数据时命中
  - 内存事先已经定义好为一个个块，Cache直接把访问字所属的块搬进来即可
  - 由于Cache是按行存储，然后把要访问的字按块搬入对应的行中，所以事实上CPU访问Cache时是检查字所属块的“块号”是否相符
  - 而块内部的字各自的地址映射排列则自有一套规则

![image-20211026121544812](计算机组织与结构.assets/image-20211026121544812.png)

#### 平均访问时间

check的时间是$T_c$, 从Cache到CPU的时间忽略不计

$T_A = p * T_C + (1-p)* (T_C + T_M)$表示的是两种情况

$T_A = T_C + (1-p)* T_M$表示两个阶段，第一个阶段是check，第二个阶段是访问主存



![image-20211026125334919](计算机组织与结构.assets/image-20211026125334919.png)

### Cache的设计要素

#### Cache容量

- 扩大Cache容量带来的结果
  - 好处：增大了命中率p
  - 坏处：增大了Cache的开销和访问时间$T_C$（Cache本身的集成度和成本不理想）
- 导致当Cache增大到一定程度后，带来的增幅已经不及开销了，所以Cache不是越大越好。

#### 映射功能

- 实现主存块到Cache行的映射
- 有两个标记，块号，块内地址
  - 所有块内的字的地址有着这样的规律：前面的位是一样的（可以作为块号），后面的位不同（可以作为块内地址）
  - 比如：假如一个块有K位，则后$log_2K$表示块内地址
- 映射方式的选择会影响Cache的组织结构



##### 直接映射（Direct mapping）

  - 将主存中的每一个块映射到**一个**固定可用的cache行中
  - 假设i是cache行号，j是主存储器的块号，C是cache的行数
    - $i = j\ mod\ C$（间隔得放，是为了尽可能让连续的块都被载入cache中）
- Cache中的标记位
  - 标记位必不可少，但是由于占空间，会有成本。所以它越短越好
  - 直接映射到同一行的不同块的低$log_2C$位都是一样的（即行号）
    - 地址中最高n位 $n = log_2M - log_2C$（M是块号的长度，C是cache行的数量）
- 例：
  - **块号从0开始编码**
  - 假设cache有4行，每行包含8个字（**cache每行的长度和主存中每个块的长度是一样的**）；主存中包含128个字。访问主存的地址长度为7位，则：
    - 块号一共有 128 / 8 = 16个，因此M = 16
    - 最低的3位：块内地址
    - 中间的2位：映射时所对应的Cache行号
    - 最高的2位：区分映射到同一行的不同块，记录为Cache标记（存在cache标记位里）
- 优点
  - 简单、快速映射、快速检查
- 缺点
  - 抖动现象：如果一个程序重复访问两个需要映射到同一行中且来自不同块的字，则这两个块不断被交换到cache中，cache的命中率降低。
- 适合大容量的cache



##### 关联映射（Associative mapping）

- 一个主存块可以装入cache任意一行
- Cache中的标记位
  - 地址中最高n位 $n = log_2M$
- 例：
  - 假设cache有4行，每行包含8个字（**cache每行的长度和主存中每个块的长度是一样的**）；主存中包含128个字。访问主存的地址长度为7位，则：
    - 块号一共有 128 / 8 = 16个，因此M = 16
    - 最低的3位：块内地址
    - 最高的4位：块号
- 优点
  - 避免抖动
- 缺点
  - 实现起来比较复杂
  - Cache搜索代价很大，即在检查的时候需要去访问Cache的每一行
- 适合容量较小的Cache



##### 组关联映射（Set associative mapping）

- Cache分成若干组，每一组包含相同数量的行，每个主存块被映射到**固定组**的**任意一行**
- 假设s是cache组号，j是主存块号，S是组数
  - $s = j\ mod\ S$
- K - 路相关联映射，K是组里面的行数

- Cache中的标记位
  - 地址中最高n位 $n = log_2M - log_2S$（M是块号的长度，S是组数）
- 例
  - 假设cache有4行，每行包含8个字，分为2组；主存中包含128个字，访问主存的地址长度为7位，则：
    - 最低的3位：块内地址
    - 中间1位：映射时所对应的Cache中的组
    - 最高的3位：区分映射到同一组的不同块，记录为Cache标记（存在cache标记位里）
- 优点
  - 结合了直接映射和关联映射的优点
- 缺点
  - 结合了直接映射和关联映射的缺点
- 面向不同容量的cache作了折中



##### 三种方式的比较

- 如果K = 1，组关联映射等同于直接映射
- 如果K = C，组关联映射等同于关联映射



##### 关联度

- 一个主存块映射到cache中可能存放的位置个数
  - 直接映射：1
  - 关联映射：C
  - 组关联映射：K
- 关联度越低，命中率越低
  - 直接映射的命中率最低，关联映射的命中率最高
- 关联度越低，判断是否命中的时间越短
  - 直接映射的命中时间最短，关联映射的命中时间最长
- 关联度越低，标记所占额外空间开销越小
  - 直接映射的标段最短，关联映射的标记最长



#### 替换算法

- 一旦cache行被占用，当新的数据块装入cache中时，原先存放的数据块将会被替换掉
- 对于直接映射，每个数据块都只有唯一对应的行可以放置，没有选择的机会
- 对于关联映射和组关联映射，每个数据块被允许在多个行中选择一个进行放置，就需要**替换算法**来决定替换哪一行中的数据块
  - 替换算法通过硬件来实现
- 目标：替换最不可能使用的块

##### 最近最少使用算法

（Least Recently Used，LRU）

- 假设：最近使用过的数据块更有可能会被再次使用
- 策略：替换掉在cache中**最长时间未被访问的数据块**

- 实现：2路组关联映射（见教材）
  - 每行包含一个USE位
  - 当同一组中的某行被访问时，将其USE位设为1，同时将另一行的USE位设为0
  - 当将新的数据块读入该组时，替换掉USE位为0的行的数据块

##### 先进先出算法

（First In First Out，FIFO）

- 假设：最近由主存载入Cache的数据块更有可能被使用
- 策略：替换掉在Cache中**停留时间最长的块**
- 实现：时间片轮转法 或 环形缓冲技术
  - 每行包含一个标识位
  - 当同一组中的某行被替换时，将其标识为1，同时将其下一行的标识设为0
    - 如果被替换的是该组中的最后一行，则将该组中的第一行的标识为设为0
  - 当讲新的数据块读入该组时，替换掉标识位为0的行中的数据块

##### 最不经常使用算法

（Last Frequently Used，LFU）

- 假设：访问越频繁的数据块越有可能被再次使用
- 策略：替换掉cache中被访问次数最少的数据块
- 实现：为每一行设置计数器

##### 随机替换算法

（Random）

- 假设：每个数据块被再次使用的可能性是相同的
- 策略：随即替换cache中的数据块
- 实现：随机替换
- 随即替换算法在性能上只稍逊于使用其他替换算法



#### 写策略

- 主存和cache的一致性
  - 当cache中的某个数据块被替换时，需要考虑该数据块是否被修改
- 两种情况
  - 如果没被修改，则该数据块可以直接被替换掉
  - 如果被修改，则在替换掉该数据块之前，必须讲修改后的数据块写回到主存中的对应位置

##### 写直达

- 所有写操作都同时对cache和主存进行
- 优点
  - 确保主存中的数据总是和cache中的数据一致，**总是最新的**
- 缺点
  - 产生大量的主存访问，减慢写操作
- 应用场景：在需要确保主存中的数据总是最新的时。比如多个cpu的计算机

##### 写回法

- 先更新cache中的数据，当cache中某个数据块被替换时，如果它被修改了，才写回主存
- 利用一个脏位（dirty bit）或者使用位（use bit）来表示块是否被修改
- 优点
  - 减少了访问主存的次数
- 缺点
  - 部分主存数据可能不是最新的
    - 部分I/O模块存取时可能无法获得最新的数据，为解决该问题会使得电路设计更加复杂且有可能带来性能瓶颈



#### 行大小

- 假设从行的大小为一个字开始，随着行大小的逐步增大，Cache的命中率会增加
  - 数据块中包含了更多周围的数据，每次会有更多的数据作为一个块装入cache中
  - 利用空间局限性
- 当行大小辩的较大之后，继续增大行大小，则cache命中率会下降
  - 当cache容量一定的前提下，较大的行会导致cache中的行数变小，导致装入cache中的数据块数量减少，进而造成数据块被频繁替换
  - 每个数据块中包含的数据在主存中位置变远，被使用的可能性减小
  - 抖动
- 行大小与命中率之间的关系较为复杂



#### Cache数目

##### 一级

- 将cache与处理器置于同一芯片（片内cache）
- 减少处理器在外部总线上的活动，从而减少了执行时间

##### 多级

- 当L1未命中时，减少处理器对总线上DRAM或ROM的访问
- 使用单独的数据路径，代替系统总线在L2缓存和处理器之间传输数据，部分处理器将L2 cache结合到处理器芯片上的

*多级cache平均访问时间的计算，多级cache的原理和好处*
